'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bessel = require('bessel');
var jStat = require('jstat');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var bessel__default = /*#__PURE__*/_interopDefaultLegacy(bessel);
var jStat__default = /*#__PURE__*/_interopDefaultLegacy(jStat);

const nil = new Error('#NULL!');
const div0 = new Error('#DIV/0!');
const value = new Error('#VALUE!');
const ref = new Error('#REF!');
const name = new Error('#NAME?');
const num = new Error('#NUM!');
const na = new Error('#N/A');
const error = new Error('#ERROR!');
const data = new Error('#GETTING_DATA');

function flattenShallow(array) {
  if (!array || !array.reduce) {
    return array
  }

  return array.reduce((a, b) => {
    const aIsArray = Array.isArray(a);
    const bIsArray = Array.isArray(b);

    if (aIsArray && bIsArray) {
      return a.concat(b)
    }

    if (aIsArray) {
      a.push(b);

      return a
    }

    if (bIsArray) {
      return [a].concat(b)
    }

    return [a, b]
  })
}

function isFlat(array) {
  if (!array) {
    return false
  }

  for (let i = 0; i < array.length; ++i) {
    if (Array.isArray(array[i])) {
      return false
    }
  }

  return true
}

function flatten() {
  let result = argsToArray.apply(null, arguments);

  while (!isFlat(result)) {
    result = flattenShallow(result);
  }

  return result
}

function argsToArray(args) {
  const result = [];

  arrayEach(args, (value) => {
    result.push(value);
  });

  return result
}

function numbers() {
  const possibleNumbers = flatten.apply(null, arguments);

  return possibleNumbers.filter((el) => typeof el === 'number')
}

function cleanFloat(number) {
  const power = 1e14;

  return Math.round(number * power) / power
}

function parseBool(bool) {
  if (typeof bool === 'boolean') {
    return bool
  }

  if (bool instanceof Error) {
    return bool
  }

  if (typeof bool === 'number') {
    return bool !== 0
  }

  if (typeof bool === 'string') {
    const up = bool.toUpperCase();

    if (up === 'TRUE') {
      return true
    }

    if (up === 'FALSE') {
      return false
    }
  }

  if (bool instanceof Date && !isNaN(bool)) {
    return true
  }

  return value
}

function parseNumber(string) {
  if (string instanceof Error) {
    return string
  }

  if (string === undefined || string === null || string === '') {
    return 0
  }

  if (typeof string === 'boolean') {
    string = +string;
  }

  if (!isNaN(string)) {
    return parseFloat(string)
  }

  return value
}

function parseString(string) {
  if (string instanceof Error) {
    return string
  }

  if (string === undefined || string === null) {
    return ''
  }

  return string.toString()
}

function parseNumberArray(arr) {
  let len;

  if (!arr || (len = arr.length) === 0) {
    return value
  }

  let parsed;

  while (len--) {
    if (arr[len] instanceof Error) {
      return arr[len]
    }

    parsed = parseNumber(arr[len]);

    if (parsed instanceof Error) {
      return parsed
    }

    arr[len] = parsed;
  }

  return arr
}

function serialNumberToDate(serial) {
  if (serial < 60) {
    serial += 1;
  }

  const utc_days = Math.floor(serial - 25569);
  const utc_value = utc_days * 86400;
  const date_info = new Date(utc_value * 1000);
  const fractional_day = serial - Math.floor(serial) + 0.0000001;

  let total_seconds = Math.floor(86400 * fractional_day);

  const seconds = total_seconds % 60;

  total_seconds -= seconds;

  const hours = Math.floor(total_seconds / (60 * 60));
  const minutes = Math.floor(total_seconds / 60) % 60;
  let days = date_info.getDate();
  let month = date_info.getMonth();

  if (serial >= 60 && serial < 61) {
    days = 29;
    month = 1;
  }

  return new Date(date_info.getFullYear(), month, days, hours, minutes, seconds)
}

function parseDate(date) {
  if (!isNaN(date)) {
    if (date instanceof Date) {
      return new Date(date)
    }

    const d = parseFloat(date);

    if (d < 0 || d >= 2958466) {
      return num
    }

    return serialNumberToDate(d)
  }

  if (typeof date === 'string') {
    date = new Date(date);

    if (!isNaN(date)) {
      return date
    }
  }

  return value
}

function parseDateArray(arr) {
  let len = arr.length;
  let parsed;

  while (len--) {
    parsed = parseDate(arr[len]);

    if (parsed === value) {
      return parsed
    }

    arr[len] = parsed;
  }

  return arr
}

function anyError() {
  for (let n = 0; n < arguments.length; n++) {
    if (arguments[n] instanceof Error) {
      return arguments[n]
    }
  }

  return undefined
}

function isDefined(arg) {
  return arg !== undefined && arg !== null
}

function anyIsError() {
  let n = arguments.length;

  while (n--) {
    if (arguments[n] instanceof Error) {
      return true
    }
  }

  return false
}

function anyIsString() {
  let n = arguments.length;

  while (n--) {
    if (typeof arguments[n] === 'string') {
      return true
    }
  }

  return false
}

function arrayValuesToNumbers(arr) {
  let n = arr.length;
  let el;

  while (n--) {
    el = arr[n];

    if (typeof el === 'number') {
      continue
    }

    if (el === true) {
      arr[n] = 1;
      continue
    }

    if (el === false) {
      arr[n] = 0;
      continue
    }

    if (typeof el === 'string') {
      const number = parseNumber(el);

      if (number instanceof Error) {
        arr[n] = 0;
      } else {
        arr[n] = number;
      }
    }
  }

  return arr
}

function rest(array, idx) {
  idx = idx || 1;

  if (!array || typeof array.slice !== 'function') {
    return array
  }

  return array.slice(idx)
}

function initial(array, idx) {
  idx = idx || 1;

  if (!array || typeof array.slice !== 'function') {
    return array
  }

  return array.slice(0, array.length - idx)
}

function arrayEach(array, iteratee) {
  let index = -1;
  const length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break
    }
  }

  return array
}

function transpose(matrix) {
  if (!matrix) {
    return value
  }

  return matrix[0].map((col, i) => matrix.map((row) => row[i]))
}

const d1900 = new Date(Date.UTC(1900, 0, 1));
const WEEK_STARTS = [
  undefined,
  0,
  1,
  undefined,
  undefined,
  undefined,
  undefined,
  undefined,
  undefined,
  undefined,
  undefined,
  undefined,
  1,
  2,
  3,
  4,
  5,
  6,
  0
];
const WEEK_TYPES = [
  [],
  [1, 2, 3, 4, 5, 6, 7],
  [7, 1, 2, 3, 4, 5, 6],
  [6, 0, 1, 2, 3, 4, 5],
  [],
  [],
  [],
  [],
  [],
  [],
  [],
  [7, 1, 2, 3, 4, 5, 6],
  [6, 7, 1, 2, 3, 4, 5],
  [5, 6, 7, 1, 2, 3, 4],
  [4, 5, 6, 7, 1, 2, 3],
  [3, 4, 5, 6, 7, 1, 2],
  [2, 3, 4, 5, 6, 7, 1],
  [1, 2, 3, 4, 5, 6, 7]
];
const WEEKEND_TYPES = [
  [],
  [6, 0],
  [0, 1],
  [1, 2],
  [2, 3],
  [3, 4],
  [4, 5],
  [5, 6],
  undefined,
  undefined,
  undefined,
  [0, 0],
  [1, 1],
  [2, 2],
  [3, 3],
  [4, 4],
  [5, 5],
  [6, 6]
];

function DATE(year, month, day) {
  let result;

  year = parseNumber(year);
  month = parseNumber(month);
  day = parseNumber(day);

  if (anyIsError(year, month, day)) {
    result = value;
  } else {
    result = new Date(year, month - 1, day);

    if (result.getFullYear() < 0) {
      result = num;
    }
  }

  return result
}

function DATEDIF(start_date, end_date, unit) {
  unit = unit.toUpperCase();
  start_date = parseDate(start_date);
  end_date = parseDate(end_date);

  const start_date_year = start_date.getFullYear();
  const start_date_month = start_date.getMonth();
  const start_date_day = start_date.getDate();
  const end_date_year = end_date.getFullYear();
  const end_date_month = end_date.getMonth();
  const end_date_day = end_date.getDate();

  let result;

  switch (unit) {
    case 'Y':
      result = Math.floor(YEARFRAC(start_date, end_date));
      break
    case 'D':
      result = DAYS(end_date, start_date);
      break
    case 'M':
      result = end_date_month - start_date_month + 12 * (end_date_year - start_date_year);

      if (end_date_day < start_date_day) {
        result--;
      }

      break
    case 'MD':
      if (start_date_day <= end_date_day) {
        result = end_date_day - start_date_day;
      } else {
        if (end_date_month === 0) {
          start_date.setFullYear(end_date_year - 1);
          start_date.setMonth(12);
        } else {
          start_date.setFullYear(end_date_year);
          start_date.setMonth(end_date_month - 1);
        }

        result = DAYS(end_date, start_date);
      }

      break
    case 'YM':
      result = end_date_month - start_date_month + 12 * (end_date_year - start_date_year);

      if (end_date_day < start_date_day) {
        result--;
      }

      result = result % 12;
      break
    case 'YD':
      if (end_date_month > start_date_month || (end_date_month === start_date_month && end_date_day < start_date_day)) {
        start_date.setFullYear(end_date_year);
      } else {
        start_date.setFullYear(end_date_year - 1);
      }

      result = DAYS(end_date, start_date);
      break
  }

  return result
}

function DATEVALUE(date_text) {
  if (typeof date_text !== 'string') {
    return value
  }

  const date = Date.parse(date_text);

  if (isNaN(date)) {
    return value
  }

  return new Date(date_text)
}

function DAY(serial_number) {
  const date = parseDate(serial_number);

  if (date instanceof Error) {
    return date
  }

  return date.getDate()
}

function startOfDay(date) {
  const newDate = new Date(date);
  newDate.setHours(0, 0, 0, 0);

  return newDate
}

function DAYS(end_date, start_date) {
  end_date = parseDate(end_date);
  start_date = parseDate(start_date);

  if (end_date instanceof Error) {
    return end_date
  }

  if (start_date instanceof Error) {
    return start_date
  }

  return serial(startOfDay(end_date)) - serial(startOfDay(start_date))
}

function DAYS360(start_date, end_date, method) {
  method = parseBool(method || 'false');
  start_date = parseDate(start_date);
  end_date = parseDate(end_date);

  if (start_date instanceof Error) {
    return start_date
  }

  if (end_date instanceof Error) {
    return end_date
  }

  if (method instanceof Error) {
    return method
  }

  const sm = start_date.getMonth();
  let em = end_date.getMonth();
  let sd, ed;

  if (method) {
    sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
    ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
  } else {
    const smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
    const emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
    sd = start_date.getDate() === smd ? 30 : start_date.getDate();

    if (end_date.getDate() === emd) {
      if (sd < 30) {
        em++;
        ed = 1;
      } else {
        ed = 30;
      }
    } else {
      ed = end_date.getDate();
    }
  }

  return 360 * (end_date.getFullYear() - start_date.getFullYear()) + 30 * (em - sm) + (ed - sd)
}

function EDATE(start_date, months) {
  start_date = parseDate(start_date);

  if (start_date instanceof Error) {
    return start_date
  }

  if (isNaN(months)) {
    return value
  }

  months = parseInt(months, 10);
  start_date.setMonth(start_date.getMonth() + months);

  return start_date
}

function EOMONTH(start_date, months) {
  start_date = parseDate(start_date);

  if (start_date instanceof Error) {
    return start_date
  }

  if (isNaN(months)) {
    return value
  }

  months = parseInt(months, 10);

  return new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0)
}

function HOUR(serial_number) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  return serial_number.getHours()
}

function INTERVAL(second) {
  if (typeof second !== 'number' && typeof second !== 'string') {
    return value
  } else {
    second = parseInt(second, 10);
  }

  let year = Math.floor(second / 946080000);
  second = second % 946080000;
  let month = Math.floor(second / 2592000);
  second = second % 2592000;
  let day = Math.floor(second / 86400);
  second = second % 86400;

  let hour = Math.floor(second / 3600);
  second = second % 3600;
  let min = Math.floor(second / 60);
  second = second % 60;
  let sec = second;

  year = year > 0 ? year + 'Y' : '';
  month = month > 0 ? month + 'M' : '';
  day = day > 0 ? day + 'D' : '';
  hour = hour > 0 ? hour + 'H' : '';
  min = min > 0 ? min + 'M' : '';
  sec = sec > 0 ? sec + 'S' : '';

  return 'P' + year + month + day + 'T' + hour + min + sec
}

function ISOWEEKNUM(date) {
  date = parseDate(date);

  if (date instanceof Error) {
    return date
  }

  date = startOfDay(date);
  date.setDate(date.getDate() + 4 - (date.getDay() || 7));
  const yearStart = new Date(date.getFullYear(), 0, 1);

  return Math.ceil(((date - yearStart) / 86400000 + 1) / 7)
}

function MINUTE(serial_number) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  return serial_number.getMinutes()
}

function MONTH(serial_number) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  return serial_number.getMonth() + 1
}

function NETWORKDAYS(start_date, end_date, holidays) {
  return NETWORKDAYS.INTL(start_date, end_date, 1, holidays)
}

NETWORKDAYS.INTL = (start_date, end_date, weekend, holidays) => {
  start_date = parseDate(start_date);

  if (start_date instanceof Error) {
    return start_date
  }

  end_date = parseDate(end_date);

  if (end_date instanceof Error) {
    return end_date
  }

  let isMask = false;
  const maskDays = [];
  const maskIndex = [1, 2, 3, 4, 5, 6, 0];
  const maskRegex = new RegExp('^[0|1]{7}$');

  if (weekend === undefined) {
    weekend = WEEKEND_TYPES[1];
  } else if (typeof weekend === 'string' && maskRegex.test(weekend)) {
    isMask = true;
    weekend = weekend.split('');

    for (let i = 0; i < weekend.length; i++) {
      if (weekend[i] === '1') {
        maskDays.push(maskIndex[i]);
      }
    }
  } else {
    weekend = WEEKEND_TYPES[weekend];
  }

  if (!(weekend instanceof Array)) {
    return value
  }

  if (holidays === undefined) {
    holidays = [];
  } else if (!(holidays instanceof Array)) {
    holidays = [holidays];
  }

  for (let i = 0; i < holidays.length; i++) {
    const h = parseDate(holidays[i]);

    if (h instanceof Error) {
      return h
    }

    holidays[i] = h;
  }

  const days = Math.round((end_date - start_date) / (1000 * 60 * 60 * 24)) + 1;
  let total = days;
  const day = start_date;

  for (let i = 0; i < days; i++) {
    const d = new Date().getTimezoneOffset() > 0 ? day.getUTCDay() : day.getDay();
    let dec = isMask ? maskDays.includes(d) : d === weekend[0] || d === weekend[1];

    for (let j = 0; j < holidays.length; j++) {
      const holiday = holidays[j];

      if (
        holiday.getDate() === day.getDate() &&
        holiday.getMonth() === day.getMonth() &&
        holiday.getFullYear() === day.getFullYear()
      ) {
        dec = true;
        break
      }
    }

    if (dec) {
      total--;
    }

    day.setDate(day.getDate() + 1);
  }

  return total
};

function NOW() {
  return new Date()
}

function SECOND(serial_number) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  return serial_number.getSeconds()
}

function TIME(hour, minute, second) {
  hour = parseNumber(hour);
  minute = parseNumber(minute);
  second = parseNumber(second);

  if (anyIsError(hour, minute, second)) {
    return value
  }

  if (hour < 0 || minute < 0 || second < 0) {
    return num
  }

  return (3600 * hour + 60 * minute + second) / 86400
}

function TIMEVALUE(time_text) {
  time_text = parseDate(time_text);

  if (time_text instanceof Error) {
    return time_text
  }

  return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400
}

function TODAY() {
  return startOfDay(new Date())
}

function WEEKDAY(serial_number, return_type) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  if (return_type === undefined) {
    return_type = 1;
  }

  const day = serial_number.getDay();

  return WEEK_TYPES[return_type][day]
}

function WEEKNUM(serial_number, return_type) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  if (return_type === undefined) {
    return_type = 1;
  }

  if (return_type === 21) {
    return ISOWEEKNUM(serial_number)
  }

  const week_start = WEEK_STARTS[return_type];
  let jan = new Date(serial_number.getFullYear(), 0, 1);
  const inc = jan.getDay() < week_start ? 1 : 0;
  jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1000;

  return Math.floor((serial_number - jan) / (1000 * 60 * 60 * 24) / 7 + 1) + inc
}

function WORKDAY(start_date, days, holidays) {
  return WORKDAY.INTL(start_date, days, 1, holidays)
}

WORKDAY.INTL = (start_date, days, weekend, holidays) => {
  start_date = parseDate(start_date);

  if (start_date instanceof Error) {
    return start_date
  }

  days = parseNumber(days);

  if (days instanceof Error) {
    return days
  }

  if (days < 0) {
    return num
  }

  if (weekend === undefined) {
    weekend = WEEKEND_TYPES[1];
  } else {
    weekend = WEEKEND_TYPES[weekend];
  }

  if (!(weekend instanceof Array)) {
    return value
  }

  if (holidays === undefined) {
    holidays = [];
  } else if (!(holidays instanceof Array)) {
    holidays = [holidays];
  }

  for (let i = 0; i < holidays.length; i++) {
    const h = parseDate(holidays[i]);

    if (h instanceof Error) {
      return h
    }

    holidays[i] = h;
  }

  let d = 0;

  while (d < days) {
    start_date.setDate(start_date.getDate() + 1);
    const day = start_date.getDay();

    if (day === weekend[0] || day === weekend[1]) {
      continue
    }

    for (let j = 0; j < holidays.length; j++) {
      const holiday = holidays[j];

      if (
        holiday.getDate() === start_date.getDate() &&
        holiday.getMonth() === start_date.getMonth() &&
        holiday.getFullYear() === start_date.getFullYear()
      ) {
        d--;
        break
      }
    }

    d++;
  }

  return start_date
};

function YEAR(serial_number) {
  serial_number = parseDate(serial_number);

  if (serial_number instanceof Error) {
    return serial_number
  }

  return serial_number.getFullYear()
}

function isLeapYear(year) {
  return new Date(year, 1, 29).getMonth() === 1
}

// TODO : Use DAYS ?
function daysBetween(start_date, end_date) {
  return Math.ceil((end_date - start_date) / 1000 / 60 / 60 / 24)
}

function YEARFRAC(start_date, end_date, basis) {
  start_date = parseDate(start_date);

  if (start_date instanceof Error) {
    return start_date
  }

  end_date = parseDate(end_date);

  if (end_date instanceof Error) {
    return end_date
  }

  basis = basis || 0;
  let sd = start_date.getDate();
  const sm = start_date.getMonth() + 1;
  const sy = start_date.getFullYear();
  let ed = end_date.getDate();
  const em = end_date.getMonth() + 1;
  const ey = end_date.getFullYear();

  switch (basis) {
    case 0:
      // US (NASD) 30/360
      if (sd === 31 && ed === 31) {
        sd = 30;
        ed = 30;
      } else if (sd === 31) {
        sd = 30;
      } else if (sd === 30 && ed === 31) {
        ed = 30;
      }

      return (ed + em * 30 + ey * 360 - (sd + sm * 30 + sy * 360)) / 360
    case 1: {
      // Actual/actual
      const feb29Between = (date1, date2) => {
        const year1 = date1.getFullYear();
        const mar1year1 = new Date(year1, 2, 1);

        if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
          return true
        }

        const year2 = date2.getFullYear();
        const mar1year2 = new Date(year2, 2, 1);

        return isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2
      };

      let ylength = 365;

      if (sy === ey || (sy + 1 === ey && (sm > em || (sm === em && sd >= ed)))) {
        if ((sy === ey && isLeapYear(sy)) || feb29Between(start_date, end_date) || (em === 1 && ed === 29)) {
          ylength = 366;
        }

        return daysBetween(start_date, end_date) / ylength
      }

      const years = ey - sy + 1;
      const days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
      const average = days / years;

      return daysBetween(start_date, end_date) / average
    }

    case 2:
      // Actual/360

      return daysBetween(start_date, end_date) / 360
    case 3:
      // Actual/365

      return daysBetween(start_date, end_date) / 365
    case 4:
      // European 30/360

      return (ed + em * 30 + ey * 360 - (sd + sm * 30 + sy * 360)) / 360
  }
}

function serial(date) {
  const addOn = date > -2203891200000 ? 2 : 1;

  return Math.ceil((date - d1900) / 86400000) + addOn
}

// TODO
function ASC() {
  throw new Error('ASC is not implemented')
}

// TODO
function BAHTTEXT() {
  throw new Error('BAHTTEXT is not implemented')
}

function CHAR(number) {
  number = parseNumber(number);

  if (number === 0) {
    return value
  }

  if (number instanceof Error) {
    return number
  }

  return String.fromCharCode(number)
}

function CLEAN(text) {
  if (anyIsError(text)) {
    return text
  }

  text = text || '';
  const re = /[\0-\x1F]/g;

  return text.replace(re, '')
}

function CODE(text) {
  if (anyIsError(text)) {
    return text
  }

  text = text || '';
  let result = text.charCodeAt(0);

  if (isNaN(result)) {
    result = value;
  }

  return result
}

function CONCATENATE() {
  const args = flatten(arguments);
  const someError = anyError.apply(undefined, args);

  if (someError) {
    return someError
  }

  let trueFound = 0;

  while ((trueFound = args.indexOf(true)) > -1) {
    args[trueFound] = 'TRUE';
  }

  let falseFound = 0;

  while ((falseFound = args.indexOf(false)) > -1) {
    args[falseFound] = 'FALSE';
  }

  return args.join('')
}

const CONCAT = CONCATENATE;

// TODO
function DBCS() {
  throw new Error('DBCS is not implemented')
}

// TODO
function DOLLAR() {
  throw new Error('DOLLAR is not implemented')
}

function EXACT(text1, text2) {
  if (arguments.length !== 2) {
    return na
  }

  const someError = anyError(text1, text2);

  if (someError) {
    return someError
  }

  text1 = parseString(text1);
  text2 = parseString(text2);

  return text1 === text2
}

function FIND(find_text, within_text, position) {
  if (arguments.length < 2) {
    return na
  }

  find_text = parseString(find_text);
  within_text = parseString(within_text);
  position = position === undefined ? 0 : position;
  const found_index = within_text.indexOf(find_text, position - 1);

  if (found_index === -1) {
    return value
  }

  return found_index + 1
}

// TODO
function FIXED() {
  throw new Error('FIXED is not implemented')
}

function HTML2TEXT(value) {
  if (anyIsError(value)) {
    return value
  }

  let result = '';

  if (value) {
    if (value instanceof Array) {
      value.forEach((line) => {
        if (result !== '') {
          result += '\n';
        }

        result += line.replace(/<(?:.|\n)*?>/gm, '');
      });
    } else {
      result = value.replace(/<(?:.|\n)*?>/gm, '');
    }
  }

  return result
}

function LEFT(text, number) {
  const someError = anyError(text, number);

  if (someError) {
    return someError
  }

  text = parseString(text);
  number = number === undefined ? 1 : number;
  number = parseNumber(number);

  if (number instanceof Error || typeof text !== 'string') {
    return value
  }

  return text.substring(0, number)
}

function LEN(text) {
  if (arguments.length === 0) {
    return error
  }

  if (text instanceof Error) {
    return text
  }

  if (Array.isArray(text)) {
    return value
  }

  const textAsString = parseString(text);

  return textAsString.length
}

function LOWER(text) {
  if (arguments.length !== 1) {
    return value
  }

  text = parseString(text);

  if (anyIsError(text)) {
    return text
  }

  return text.toLowerCase()
}

function MID(text, start, number) {
  if (start === undefined || start === null) {
    return value
  }

  start = parseNumber(start);
  number = parseNumber(number);

  if (anyIsError(start, number) || typeof text !== 'string') {
    return number
  }

  const begin = start - 1;
  const end = begin + number;

  return text.substring(begin, end)
}

// TODO
function NUMBERVALUE(text, decimal_separator, group_separator) {
  decimal_separator = typeof decimal_separator === 'undefined' ? '.' : decimal_separator;
  group_separator = typeof group_separator === 'undefined' ? ',' : group_separator;

  return Number(text.replace(decimal_separator, '.').replace(group_separator, ''))
}

// TODO
function PRONETIC() {
  throw new Error('PRONETIC is not implemented')
}

function PROPER(text) {
  if (anyIsError(text)) {
    return text
  }

  if (isNaN(text) && typeof text === 'number') {
    return value
  }

  text = parseString(text);

  return text.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase())
}

function REGEXEXTRACT(text, regular_expression) {
  if (arguments.length < 2) {
    return na
  }

  const match = text.match(new RegExp(regular_expression));

  return match ? match[match.length > 1 ? match.length - 1 : 0] : null
}

function REGEXMATCH(text, regular_expression, full) {
  if (arguments.length < 2) {
    return na
  }

  const match = text.match(new RegExp(regular_expression));

  return full ? match : !!match
}

function REGEXREPLACE(text, regular_expression, replacement) {
  if (arguments.length < 3) {
    return na
  }

  return text.replace(new RegExp(regular_expression), replacement)
}

function REPLACE(text, position, length, new_text) {
  position = parseNumber(position);
  length = parseNumber(length);

  if (anyIsError(position, length) || typeof text !== 'string' || typeof new_text !== 'string') {
    return value
  }

  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length)
}

function REPT(text, number) {
  const someError = anyError(text, number);

  if (someError) {
    return someError
  }

  text = parseString(text);
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return new Array(number + 1).join(text)
}

function RIGHT(text, number) {
  const someError = anyError(text, number);

  if (someError) {
    return someError
  }

  text = parseString(text);
  number = number === undefined ? 1 : number;
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return text.substring(text.length - number)
}

function SEARCH(find_text, within_text, position) {
  let foundAt;

  if (typeof find_text !== 'string' || typeof within_text !== 'string') {
    return value
  }

  position = position === undefined ? 0 : position;
  foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1) + 1;

  return foundAt === 0 ? value : foundAt
}

function SPLIT(text, separator) {
  return text.split(separator)
}

function SUBSTITUTE(text, old_text, new_text, occurrence) {
  if (arguments.length < 3) {
    return na
  }

  if (!text || !old_text) {
    return text
  } else if (occurrence === undefined) {
    return text.split(old_text).join(new_text)
  } else {
    occurrence = Math.floor(Number(occurrence));

    if (Number.isNaN(occurrence) || occurrence <= 0) {
      return value
    }

    let index = 0;
    let i = 0;

    while (index > -1 && text.indexOf(old_text, index) > -1) {
      index = text.indexOf(old_text, index + 1);
      i++;

      if (index > -1 && i === occurrence) {
        return text.substring(0, index) + new_text + text.substring(index + old_text.length)
      }
    }

    return text
  }
}

function T$1(value) {
  if (value instanceof Error) {
    return value
  }

  return typeof value === 'string' ? value : ''
}

// TODO incomplete implementation
function TEXT() {
  throw new Error('TEXT is not implemented')
}

function TEXTJOIN(delimiter, ignore_empty, ...args) {
  if (typeof ignore_empty !== 'boolean') {
    ignore_empty = parseBool(ignore_empty);
  }

  if (arguments.length < 3) {
    return na
  }

  delimiter = delimiter !== null && delimiter !== undefined ? delimiter : '';

  let flatArgs = flatten(args);
  let textToJoin = ignore_empty ? flatArgs.filter((text) => text) : flatArgs;

  if (Array.isArray(delimiter)) {
    delimiter = flatten(delimiter);

    let chunks = textToJoin.map((item) => [item]);
    let index = 0;

    for (let i = 0; i < chunks.length - 1; i++) {
      chunks[i].push(delimiter[index]);
      index++;

      if (index === delimiter.length) {
        index = 0;
      }
    }

    textToJoin = flatten(chunks);

    return textToJoin.join('')
  }

  return textToJoin.join(delimiter)
}

function TRIM(text) {
  text = parseString(text);

  if (text instanceof Error) {
    return text
  }

  return text.replace(/\s+/g, ' ').trim()
}

const UNICHAR = CHAR;

const UNICODE = CODE;

function UPPER(text) {
  text = parseString(text);

  if (text instanceof Error) {
    return text
  }

  return text.toUpperCase()
}

function VALUE(num) {
  const anyError$1 = anyError(num);

  if (anyError$1) {
    return anyError$1
  }

  if (typeof num === 'number') {
    return num
  }

  if (typeof num !== 'string') {
    return value
  }

  const isPercent = /(%)$/.test(num) || /^(%)/.test(num);
  num = num.replace(/^[^0-9-]{0,3}/, '');
  num = num.replace(/[^0-9]{0,3}$/, '');
  num = num.replace(/[ ,]/g, '');

  if (num === '') {
    return value
  }

  let output = Number(num);

  if (isNaN(output)) {
    return value
  }

  output = output || 0;

  if (isPercent) {
    output = output * 0.01;
  }

  return output
}

function isValidBinaryNumber(number) {
  return /^[01]{1,10}$/.test(number)
}

function BESSELI(x, n) {
  x = parseNumber(x);
  n = parseNumber(n);

  if (anyIsError(x, n)) {
    return value
  }

  return bessel__default["default"].besseli(x, n)
}

function BESSELJ(x, n) {
  x = parseNumber(x);
  n = parseNumber(n);

  if (anyIsError(x, n)) {
    return value
  }

  return bessel__default["default"].besselj(x, n)
}

function BESSELK(x, n) {
  x = parseNumber(x);
  n = parseNumber(n);

  if (anyIsError(x, n)) {
    return value
  }

  return bessel__default["default"].besselk(x, n)
}

function BESSELY(x, n) {
  x = parseNumber(x);
  n = parseNumber(n);

  if (anyIsError(x, n)) {
    return value
  }

  return bessel__default["default"].bessely(x, n)
}

function BIN2DEC(number) {
  // Return error if number is not binary or contains more than 10 characters (10 digits)
  if (!isValidBinaryNumber(number)) {
    return num
  }

  // Convert binary number to decimal
  const result = parseInt(number, 2);

  // Handle negative numbers
  const stringified = number.toString();

  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
    return parseInt(stringified.substring(1), 2) - 512
  } else {
    return result
  }
}

function BIN2HEX(number, places) {
  // Return error if number is not binary or contains more than 10 characters (10 digits)
  if (!isValidBinaryNumber(number)) {
    return num
  }

  // Ignore places and return a 10-character hexadecimal number if number is negative
  const stringified = number.toString();

  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16)
  }

  // Convert binary number to hexadecimal
  const result = parseInt(number, 2).toString(16);

  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
  if (places === undefined) {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function BIN2OCT(number, places) {
  // Return error if number is not binary or contains more than 10 characters (10 digits)
  if (!isValidBinaryNumber(number)) {
    return num
  }

  // Ignore places and return a 10-character octal number if number is negative
  const stringified = number.toString();

  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8)
  }

  // Convert binary number to octal
  const result = parseInt(number, 2).toString(8);

  // Return octal number using the minimum number of characters necessary if places is undefined
  if (places === undefined) {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function BITAND(number1, number2) {
  // Return error if either number is a non-numeric value
  number1 = parseNumber(number1);
  number2 = parseNumber(number2);

  if (anyIsError(number1, number2)) {
    return value
  }

  // Return error if either number is less than 0
  if (number1 < 0 || number2 < 0) {
    return num
  }

  // Return error if either number is a non-integer
  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
    return num
  }

  // Return error if either number is greater than (2^48)-1
  if (number1 > 281474976710655 || number2 > 281474976710655) {
    return num
  }

  // Return bitwise AND of two numbers
  return number1 & number2
}

function BITLSHIFT(number, shift) {
  number = parseNumber(number);
  shift = parseNumber(shift);

  if (anyIsError(number, shift)) {
    return value
  }

  // Return error if number is less than 0
  if (number < 0) {
    return num
  }

  // Return error if number is a non-integer
  if (Math.floor(number) !== number) {
    return num
  }

  // Return error if number is greater than (2^48)-1
  if (number > 281474976710655) {
    return num
  }

  // Return error if the absolute value of shift is greater than 53
  if (Math.abs(shift) > 53) {
    return num
  }

  // Return number shifted by shift bits to the left or to the right if shift is negative
  return shift >= 0 ? number << shift : number >> -shift
}

function BITOR(number1, number2) {
  number1 = parseNumber(number1);
  number2 = parseNumber(number2);

  if (anyIsError(number1, number2)) {
    return value
  }

  // Return error if either number is less than 0
  if (number1 < 0 || number2 < 0) {
    return num
  }

  // Return error if either number is a non-integer
  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
    return num
  }

  // Return error if either number is greater than (2^48)-1
  if (number1 > 281474976710655 || number2 > 281474976710655) {
    return num
  }

  // Return bitwise OR of two numbers
  return number1 | number2
}

function BITRSHIFT(number, shift) {
  number = parseNumber(number);
  shift = parseNumber(shift);

  if (anyIsError(number, shift)) {
    return value
  }

  // Return error if number is less than 0
  if (number < 0) {
    return num
  }

  // Return error if number is a non-integer
  if (Math.floor(number) !== number) {
    return num
  }

  // Return error if number is greater than (2^48)-1
  if (number > 281474976710655) {
    return num
  }

  // Return error if the absolute value of shift is greater than 53
  if (Math.abs(shift) > 53) {
    return num
  }

  // Return number shifted by shift bits to the right or to the left if shift is negative
  return shift >= 0 ? number >> shift : number << -shift
}

function BITXOR(number1, number2) {
  number1 = parseNumber(number1);
  number2 = parseNumber(number2);

  if (anyIsError(number1, number2)) {
    return value
  }

  // Return error if either number is less than 0
  if (number1 < 0 || number2 < 0) {
    return num
  }

  // Return error if either number is a non-integer
  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
    return num
  }

  // Return error if either number is greater than (2^48)-1
  if (number1 > 281474976710655 || number2 > 281474976710655) {
    return num
  }

  // Return bitwise XOR of two numbers
  return number1 ^ number2
}

function COMPLEX(real, imaginary, suffix) {
  real = parseNumber(real);
  imaginary = parseNumber(imaginary);

  if (anyIsError(real, imaginary)) {
    return real
  }

  // Set suffix
  suffix = suffix === undefined ? 'i' : suffix;

  // Return error if suffix is neither "i" nor "j"
  if (suffix !== 'i' && suffix !== 'j') {
    return value
  }

  // Return complex number
  if (real === 0 && imaginary === 0) {
    return 0
  } else if (real === 0) {
    return imaginary === 1 ? suffix : imaginary.toString() + suffix
  } else if (imaginary === 0) {
    return real.toString()
  } else {
    const sign = imaginary > 0 ? '+' : '';
    return real.toString() + sign + (imaginary === 1 ? suffix : imaginary.toString() + suffix)
  }
}

function CONVERT(number, from_unit, to_unit) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  // List of units supported by CONVERT and units defined by the International System of Units
  // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
  const units = [
    ['a.u. of action', '?', null, 'action', false, false, 1.05457168181818e-34],
    ['a.u. of charge', 'e', null, 'electric_charge', false, false, 1.60217653141414e-19],
    ['a.u. of energy', 'Eh', null, 'energy', false, false, 4.35974417757576e-18],
    ['a.u. of length', 'a?', null, 'length', false, false, 5.29177210818182e-11],
    ['a.u. of mass', 'm?', null, 'mass', false, false, 9.10938261616162e-31],
    ['a.u. of time', '?/Eh', null, 'time', false, false, 2.41888432650516e-17],
    ['admiralty knot', 'admkn', null, 'speed', false, true, 0.514773333],
    ['ampere', 'A', null, 'electric_current', true, false, 1],
    ['ampere per meter', 'A/m', null, 'magnetic_field_intensity', true, false, 1],
    ['ångström', 'Å', ['ang'], 'length', false, true, 1e-10],
    ['are', 'ar', null, 'area', false, true, 100],
    ['astronomical unit', 'ua', null, 'length', false, false, 1.49597870691667e-11],
    ['bar', 'bar', null, 'pressure', false, false, 100000],
    ['barn', 'b', null, 'area', false, false, 1e-28],
    ['becquerel', 'Bq', null, 'radioactivity', true, false, 1],
    ['bit', 'bit', ['b'], 'information', false, true, 1],
    ['btu', 'BTU', ['btu'], 'energy', false, true, 1055.05585262],
    ['byte', 'byte', null, 'information', false, true, 8],
    ['candela', 'cd', null, 'luminous_intensity', true, false, 1],
    ['candela per square metre', 'cd/m?', null, 'luminance', true, false, 1],
    ['coulomb', 'C', null, 'electric_charge', true, false, 1],
    ['cubic ångström', 'ang3', ['ang^3'], 'volume', false, true, 1e-30],
    ['cubic foot', 'ft3', ['ft^3'], 'volume', false, true, 0.028316846592],
    ['cubic inch', 'in3', ['in^3'], 'volume', false, true, 0.000016387064],
    ['cubic light-year', 'ly3', ['ly^3'], 'volume', false, true, 8.46786664623715e-47],
    ['cubic metre', 'm?', null, 'volume', true, true, 1],
    ['cubic mile', 'mi3', ['mi^3'], 'volume', false, true, 4168181825.44058],
    ['cubic nautical mile', 'Nmi3', ['Nmi^3'], 'volume', false, true, 6352182208],
    ['cubic Pica', 'Pica3', ['Picapt3', 'Pica^3', 'Picapt^3'], 'volume', false, true, 7.58660370370369e-8],
    ['cubic yard', 'yd3', ['yd^3'], 'volume', false, true, 0.764554857984],
    ['cup', 'cup', null, 'volume', false, true, 0.0002365882365],
    ['dalton', 'Da', ['u'], 'mass', false, false, 1.66053886282828e-27],
    ['day', 'd', ['day'], 'time', false, true, 86400],
    ['degree', '°', null, 'angle', false, false, 0.0174532925199433],
    ['degrees Rankine', 'Rank', null, 'temperature', false, true, 0.555555555555556],
    ['dyne', 'dyn', ['dy'], 'force', false, true, 0.00001],
    ['electronvolt', 'eV', ['ev'], 'energy', false, true, 1.60217656514141],
    ['ell', 'ell', null, 'length', false, true, 1.143],
    ['erg', 'erg', ['e'], 'energy', false, true, 1e-7],
    ['farad', 'F', null, 'electric_capacitance', true, false, 1],
    ['fluid ounce', 'oz', null, 'volume', false, true, 0.0000295735295625],
    ['foot', 'ft', null, 'length', false, true, 0.3048],
    ['foot-pound', 'flb', null, 'energy', false, true, 1.3558179483314],
    ['gal', 'Gal', null, 'acceleration', false, false, 0.01],
    ['gallon', 'gal', null, 'volume', false, true, 0.003785411784],
    ['gauss', 'G', ['ga'], 'magnetic_flux_density', false, true, 1],
    ['grain', 'grain', null, 'mass', false, true, 0.0000647989],
    ['gram', 'g', null, 'mass', false, true, 0.001],
    ['gray', 'Gy', null, 'absorbed_dose', true, false, 1],
    ['gross registered ton', 'GRT', ['regton'], 'volume', false, true, 2.8316846592],
    ['hectare', 'ha', null, 'area', false, true, 10000],
    ['henry', 'H', null, 'inductance', true, false, 1],
    ['hertz', 'Hz', null, 'frequency', true, false, 1],
    ['horsepower', 'HP', ['h'], 'power', false, true, 745.69987158227],
    ['horsepower-hour', 'HPh', ['hh', 'hph'], 'energy', false, true, 2684519.538],
    ['hour', 'h', ['hr'], 'time', false, true, 3600],
    ['imperial gallon (U.K.)', 'uk_gal', null, 'volume', false, true, 0.00454609],
    ['imperial hundredweight', 'lcwt', ['uk_cwt', 'hweight'], 'mass', false, true, 50.802345],
    ['imperial quart (U.K)', 'uk_qt', null, 'volume', false, true, 0.0011365225],
    ['imperial ton', 'brton', ['uk_ton', 'LTON'], 'mass', false, true, 1016.046909],
    ['inch', 'in', null, 'length', false, true, 0.0254],
    ['international acre', 'uk_acre', null, 'area', false, true, 4046.8564224],
    ['IT calorie', 'cal', null, 'energy', false, true, 4.1868],
    ['joule', 'J', null, 'energy', true, true, 1],
    ['katal', 'kat', null, 'catalytic_activity', true, false, 1],
    ['kelvin', 'K', ['kel'], 'temperature', true, true, 1],
    ['kilogram', 'kg', null, 'mass', true, true, 1],
    ['knot', 'kn', null, 'speed', false, true, 0.514444444444444],
    ['light-year', 'ly', null, 'length', false, true, 9460730472580800],
    ['litre', 'L', ['l', 'lt'], 'volume', false, true, 0.001],
    ['lumen', 'lm', null, 'luminous_flux', true, false, 1],
    ['lux', 'lx', null, 'illuminance', true, false, 1],
    ['maxwell', 'Mx', null, 'magnetic_flux', false, false, 1e-18],
    ['measurement ton', 'MTON', null, 'volume', false, true, 1.13267386368],
    ['meter per hour', 'm/h', ['m/hr'], 'speed', false, true, 0.00027777777777778],
    ['meter per second', 'm/s', ['m/sec'], 'speed', true, true, 1],
    ['meter per second squared', 'm?s??', null, 'acceleration', true, false, 1],
    ['parsec', 'pc', ['parsec'], 'length', false, true, 30856775814671900],
    ['meter squared per second', 'm?/s', null, 'kinematic_viscosity', true, false, 1],
    ['metre', 'm', null, 'length', true, true, 1],
    ['miles per hour', 'mph', null, 'speed', false, true, 0.44704],
    ['millimetre of mercury', 'mmHg', null, 'pressure', false, false, 133.322],
    ['minute', '?', null, 'angle', false, false, 0.000290888208665722],
    ['minute', 'min', ['mn'], 'time', false, true, 60],
    ['modern teaspoon', 'tspm', null, 'volume', false, true, 0.000005],
    ['mole', 'mol', null, 'amount_of_substance', true, false, 1],
    ['morgen', 'Morgen', null, 'area', false, true, 2500],
    ['n.u. of action', '?', null, 'action', false, false, 1.05457168181818e-34],
    ['n.u. of mass', 'm?', null, 'mass', false, false, 9.10938261616162e-31],
    ['n.u. of speed', 'c?', null, 'speed', false, false, 299792458],
    ['n.u. of time', '?/(me?c??)', null, 'time', false, false, 1.28808866778687e-21],
    ['nautical mile', 'M', ['Nmi'], 'length', false, true, 1852],
    ['newton', 'N', null, 'force', true, true, 1],
    ['œrsted', 'Oe ', null, 'magnetic_field_intensity', false, false, 79.5774715459477],
    ['ohm', 'Ω', null, 'electric_resistance', true, false, 1],
    ['ounce mass', 'ozm', null, 'mass', false, true, 0.028349523125],
    ['pascal', 'Pa', null, 'pressure', true, false, 1],
    ['pascal second', 'Pa?s', null, 'dynamic_viscosity', true, false, 1],
    ['pferdestärke', 'PS', null, 'power', false, true, 735.49875],
    ['phot', 'ph', null, 'illuminance', false, false, 0.0001],
    ['pica (1/6 inch)', 'pica', null, 'length', false, true, 0.00035277777777778],
    ['pica (1/72 inch)', 'Pica', ['Picapt'], 'length', false, true, 0.00423333333333333],
    ['poise', 'P', null, 'dynamic_viscosity', false, false, 0.1],
    ['pond', 'pond', null, 'force', false, true, 0.00980665],
    ['pound force', 'lbf', null, 'force', false, true, 4.4482216152605],
    ['pound mass', 'lbm', null, 'mass', false, true, 0.45359237],
    ['quart', 'qt', null, 'volume', false, true, 0.000946352946],
    ['radian', 'rad', null, 'angle', true, false, 1],
    ['second', '?', null, 'angle', false, false, 0.00000484813681109536],
    ['second', 's', ['sec'], 'time', true, true, 1],
    ['short hundredweight', 'cwt', ['shweight'], 'mass', false, true, 45.359237],
    ['siemens', 'S', null, 'electrical_conductance', true, false, 1],
    ['sievert', 'Sv', null, 'equivalent_dose', true, false, 1],
    ['slug', 'sg', null, 'mass', false, true, 14.59390294],
    ['square ångström', 'ang2', ['ang^2'], 'area', false, true, 1e-20],
    ['square foot', 'ft2', ['ft^2'], 'area', false, true, 0.09290304],
    ['square inch', 'in2', ['in^2'], 'area', false, true, 0.00064516],
    ['square light-year', 'ly2', ['ly^2'], 'area', false, true, 8.95054210748189e31],
    ['square meter', 'm?', null, 'area', true, true, 1],
    ['square mile', 'mi2', ['mi^2'], 'area', false, true, 2589988.110336],
    ['square nautical mile', 'Nmi2', ['Nmi^2'], 'area', false, true, 3429904],
    ['square Pica', 'Pica2', ['Picapt2', 'Pica^2', 'Picapt^2'], 'area', false, true, 0.00001792111111111],
    ['square yard', 'yd2', ['yd^2'], 'area', false, true, 0.83612736],
    ['statute mile', 'mi', null, 'length', false, true, 1609.344],
    ['steradian', 'sr', null, 'solid_angle', true, false, 1],
    ['stilb', 'sb', null, 'luminance', false, false, 0.0001],
    ['stokes', 'St', null, 'kinematic_viscosity', false, false, 0.0001],
    ['stone', 'stone', null, 'mass', false, true, 6.35029318],
    ['tablespoon', 'tbs', null, 'volume', false, true, 0.0000147868],
    ['teaspoon', 'tsp', null, 'volume', false, true, 0.00000492892],
    ['tesla', 'T', null, 'magnetic_flux_density', true, true, 1],
    ['thermodynamic calorie', 'c', null, 'energy', false, true, 4.184],
    ['ton', 'ton', null, 'mass', false, true, 907.18474],
    ['tonne', 't', null, 'mass', false, false, 1000],
    ['U.K. pint', 'uk_pt', null, 'volume', false, true, 0.00056826125],
    ['U.S. bushel', 'bushel', null, 'volume', false, true, 0.03523907],
    ['U.S. oil barrel', 'barrel', null, 'volume', false, true, 0.158987295],
    ['U.S. pint', 'pt', ['us_pt'], 'volume', false, true, 0.000473176473],
    ['U.S. survey mile', 'survey_mi', null, 'length', false, true, 1609.347219],
    ['U.S. survey/statute acre', 'us_acre', null, 'area', false, true, 4046.87261],
    ['volt', 'V', null, 'voltage', true, false, 1],
    ['watt', 'W', null, 'power', true, true, 1],
    ['watt-hour', 'Wh', ['wh'], 'energy', false, true, 3600],
    ['weber', 'Wb', null, 'magnetic_flux', true, false, 1],
    ['yard', 'yd', null, 'length', false, true, 0.9144],
    ['year', 'yr', null, 'time', false, true, 31557600]
  ];

  // Binary prefixes
  // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
  const binary_prefixes = {
    Yi: ['yobi', 80, 1208925819614629174706176, 'Yi', 'yotta'],
    Zi: ['zebi', 70, 1180591620717411303424, 'Zi', 'zetta'],
    Ei: ['exbi', 60, 1152921504606846976, 'Ei', 'exa'],
    Pi: ['pebi', 50, 1125899906842624, 'Pi', 'peta'],
    Ti: ['tebi', 40, 1099511627776, 'Ti', 'tera'],
    Gi: ['gibi', 30, 1073741824, 'Gi', 'giga'],
    Mi: ['mebi', 20, 1048576, 'Mi', 'mega'],
    ki: ['kibi', 10, 1024, 'ki', 'kilo']
  };

  // Unit prefixes
  // [Name, Multiplier, Abbreviation]
  const unit_prefixes = {
    Y: ['yotta', 1e24, 'Y'],
    Z: ['zetta', 1e21, 'Z'],
    E: ['exa', 1e18, 'E'],
    P: ['peta', 1e15, 'P'],
    T: ['tera', 1e12, 'T'],
    G: ['giga', 1e9, 'G'],
    M: ['mega', 1e6, 'M'],
    k: ['kilo', 1e3, 'k'],
    h: ['hecto', 1e2, 'h'],
    e: ['dekao', 1e1, 'e'],
    d: ['deci', 1e-1, 'd'],
    c: ['centi', 1e-2, 'c'],
    m: ['milli', 1e-3, 'm'],
    u: ['micro', 1e-6, 'u'],
    n: ['nano', 1e-9, 'n'],
    p: ['pico', 1e-12, 'p'],
    f: ['femto', 1e-15, 'f'],
    a: ['atto', 1e-18, 'a'],
    z: ['zepto', 1e-21, 'z'],
    y: ['yocto', 1e-24, 'y']
  };

  // Initialize units and multipliers
  let from = null;
  let to = null;
  let base_from_unit = from_unit;
  let base_to_unit = to_unit;
  let from_multiplier = 1;
  let to_multiplier = 1;
  let alt;

  // Lookup from and to units
  for (let i = 0; i < units.length; i++) {
    alt = units[i][2] === null ? [] : units[i][2];

    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
      from = units[i];
    }

    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
      to = units[i];
    }
  }

  // Lookup from prefix
  if (from === null) {
    const from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
    let from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];

    // Handle dekao unit prefix (only unit prefix with two characters)
    if (from_unit.substring(0, 2) === 'da') {
      from_unit_prefix = ['dekao', 1e1, 'da'];
    }

    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
    if (from_binary_prefix) {
      from_multiplier = from_binary_prefix[2];
      base_from_unit = from_unit.substring(2);
    } else if (from_unit_prefix) {
      from_multiplier = from_unit_prefix[1];
      base_from_unit = from_unit.substring(from_unit_prefix[2].length);
    }

    // Lookup from unit
    for (let j = 0; j < units.length; j++) {
      alt = units[j][2] === null ? [] : units[j][2];

      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
        from = units[j];
      }
    }
  }

  // Lookup to prefix
  if (to === null) {
    const to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
    let to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];

    // Handle dekao unit prefix (only unit prefix with two characters)
    if (to_unit.substring(0, 2) === 'da') {
      to_unit_prefix = ['dekao', 1e1, 'da'];
    }

    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
    if (to_binary_prefix) {
      to_multiplier = to_binary_prefix[2];
      base_to_unit = to_unit.substring(2);
    } else if (to_unit_prefix) {
      to_multiplier = to_unit_prefix[1];
      base_to_unit = to_unit.substring(to_unit_prefix[2].length);
    }

    // Lookup to unit
    for (let k = 0; k < units.length; k++) {
      alt = units[k][2] === null ? [] : units[k][2];

      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
        to = units[k];
      }
    }
  }

  // Return error if a unit does not exist
  if (from === null || to === null) {
    return na
  }

  // Return error if units represent different quantities
  if (from[3] !== to[3]) {
    return na
  }

  // Return converted number
  return (number * from[6] * from_multiplier) / (to[6] * to_multiplier)
}

function DEC2BIN(number, places) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  // Return error if number is not decimal, is lower than -512, or is greater than 511
  if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
    return num
  }

  // Ignore places and return a 10-character binary number if number is negative
  if (number < 0) {
    return '1' + REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2)
  }

  // Convert decimal number to binary
  const result = parseInt(number, 10).toString(2);

  // Return binary number using the minimum number of characters necessary if places is undefined
  if (typeof places === 'undefined') {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function DEC2HEX(number, places) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
  if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
    return num
  }

  // Ignore places and return a 10-character hexadecimal number if number is negative
  if (number < 0) {
    return (1099511627776 + number).toString(16)
  }

  // Convert decimal number to hexadecimal
  const result = parseInt(number, 10).toString(16);

  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
  if (typeof places === 'undefined') {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function DEC2OCT(number, places) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
  if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
    return num
  }

  // Ignore places and return a 10-character octal number if number is negative
  if (number < 0) {
    return (1073741824 + number).toString(8)
  }

  // Convert decimal number to octal
  const result = parseInt(number, 10).toString(8);

  // Return octal number using the minimum number of characters necessary if places is undefined
  if (typeof places === 'undefined') {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function DELTA(number1, number2) {
  // Set number2 to zero if undefined
  number2 = number2 === undefined ? 0 : number2;
  number1 = parseNumber(number1);
  number2 = parseNumber(number2);

  if (anyIsError(number1, number2)) {
    return value
  }

  // Return delta
  return number1 === number2 ? 1 : 0
}

// TODO: why is upper_bound not used ? The excel documentation has no examples with upper_bound
function ERF(lower_bound, upper_bound) {
  // Set number2 to zero if undefined
  upper_bound = upper_bound === undefined ? 0 : upper_bound;

  lower_bound = parseNumber(lower_bound);
  upper_bound = parseNumber(upper_bound);

  if (anyIsError(lower_bound, upper_bound)) {
    return value
  }

  return jStat__default["default"].erf(lower_bound)
}

// TODO
ERF.PRECISE = () => {
  throw new Error('ERF.PRECISE is not implemented')
};

function ERFC(x) {
  // Return error if x is not a number
  if (isNaN(x)) {
    return value
  }

  return jStat__default["default"].erfc(x)
}

// TODO
ERFC.PRECISE = () => {
  throw new Error('ERFC.PRECISE is not implemented')
};

function GESTEP(number, step) {
  step = step || 0;
  number = parseNumber(number);

  if (anyIsError(step, number)) {
    return number
  }

  // Return delta
  return number >= step ? 1 : 0
}

function HEX2BIN(number, places) {
  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
    return num
  }

  // Check if number is negative
  const negative = !!(number.length === 10 && number.substring(0, 1).toLowerCase() === 'f');

  // Convert hexadecimal number to decimal
  const decimal = negative ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);

  // Return error if number is lower than -512 or greater than 511
  if (decimal < -512 || decimal > 511) {
    return num
  }

  // Ignore places and return a 10-character binary number if number is negative
  if (negative) {
    return '1' + REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2)
  }

  // Convert decimal number to binary
  const result = decimal.toString(2);

  // Return binary number using the minimum number of characters necessary if places is undefined
  if (places === undefined) {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function HEX2DEC(number) {
  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
    return num
  }

  // Convert hexadecimal number to decimal
  const decimal = parseInt(number, 16);

  // Return decimal number
  return decimal >= 549755813888 ? decimal - 1099511627776 : decimal
}

function HEX2OCT(number, places) {
  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
    return num
  }

  // Convert hexadecimal number to decimal
  const decimal = parseInt(number, 16);

  // Return error if number is positive and greater than 0x1fffffff (536870911)
  if (decimal > 536870911 && decimal < 1098974756864) {
    return num
  }

  // Ignore places and return a 10-character octal number if number is negative
  if (decimal >= 1098974756864) {
    return (decimal - 1098437885952).toString(8)
  }

  // Convert decimal number to octal
  const result = decimal.toString(8);

  // Return octal number using the minimum number of characters necessary if places is undefined
  if (places === undefined) {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function IMABS(inumber) {
  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  // Return error if either coefficient is not a number
  if (anyIsError(x, y)) {
    return value
  }

  // Return absolute value of complex number
  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
}

function IMAGINARY(inumber) {
  if (inumber === undefined || inumber === true || inumber === false) {
    return value
  }

  // Return 0 if inumber is equal to 0
  if (inumber === 0 || inumber === '0') {
    return 0
  }

  // Handle special cases
  if (['i', 'j'].indexOf(inumber) >= 0) {
    return 1
  }

  // Force string type
  inumber = inumber + '';

  // Normalize imaginary coefficient
  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');

  // Lookup sign
  let plus = inumber.indexOf('+');
  let minus = inumber.indexOf('-');

  if (plus === 0) {
    plus = inumber.indexOf('+', 1);
  }

  if (minus === 0) {
    minus = inumber.indexOf('-', 1);
  }

  // Lookup imaginary unit
  const last = inumber.substring(inumber.length - 1, inumber.length);
  const unit = last === 'i' || last === 'j';

  if (plus >= 0 || minus >= 0) {
    // Return error if imaginary unit is neither i nor j
    if (!unit) {
      return num
    }

    // Return imaginary coefficient of complex number
    if (plus >= 0) {
      return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))
        ? num
        : Number(inumber.substring(plus + 1, inumber.length - 1))
    } else {
      return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))
        ? num
        : -Number(inumber.substring(minus + 1, inumber.length - 1))
    }
  } else {
    if (unit) {
      return isNaN(inumber.substring(0, inumber.length - 1)) ? num : inumber.substring(0, inumber.length - 1)
    } else {
      return isNaN(inumber) ? num : 0
    }
  }
}

function IMARGUMENT(inumber) {
  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  // Return error if either coefficient is not a number
  if (anyIsError(x, y)) {
    return value
  }

  // Return error if inumber is equal to zero
  if (x === 0 && y === 0) {
    return div0
  }

  // Return PI/2 if x is equal to zero and y is positive
  if (x === 0 && y > 0) {
    return Math.PI / 2
  }

  // Return -PI/2 if x is equal to zero and y is negative
  if (x === 0 && y < 0) {
    return -Math.PI / 2
  }

  // Return zero if x is negative and y is equal to zero
  if (y === 0 && x > 0) {
    return 0
  }

  // Return zero if x is negative and y is equal to zero
  if (y === 0 && x < 0) {
    return -Math.PI
  }

  // Return argument of complex number
  if (x > 0) {
    return Math.atan(y / x)
  } else if (x < 0 && y >= 0) {
    return Math.atan(y / x) + Math.PI
  } else {
    return Math.atan(y / x) - Math.PI
  }
}

function IMCONJUGATE(inumber) {
  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return conjugate of complex number
  return y !== 0 ? COMPLEX(x, -y, unit) : inumber
}

function IMCOS(inumber) {
  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return cosine of complex number
  return COMPLEX(
    (Math.cos(x) * (Math.exp(y) + Math.exp(-y))) / 2,
    (-Math.sin(x) * (Math.exp(y) - Math.exp(-y))) / 2,
    unit
  )
}

function IMCOSH(inumber) {
  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return hyperbolic cosine of complex number
  return COMPLEX(
    (Math.cos(y) * (Math.exp(x) + Math.exp(-x))) / 2,
    (Math.sin(y) * (Math.exp(x) - Math.exp(-x))) / 2,
    unit
  )
}

function IMCOT(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Return cotangent of complex number
  return IMDIV(IMCOS(inumber), IMSIN(inumber))
}

function IMDIV(inumber1, inumber2) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const a = IMREAL(inumber1);
  const b = IMAGINARY(inumber1);
  const c = IMREAL(inumber2);
  const d = IMAGINARY(inumber2);

  if (anyIsError(a, b, c, d)) {
    return value
  }

  // Lookup imaginary unit
  const unit1 = inumber1.substring(inumber1.length - 1);
  const unit2 = inumber2.substring(inumber2.length - 1);
  let unit = 'i';

  if (unit1 === 'j') {
    unit = 'j';
  } else if (unit2 === 'j') {
    unit = 'j';
  }

  // Return error if inumber2 is null
  if (c === 0 && d === 0) {
    return num
  }

  // Return exponential of complex number
  const den = c * c + d * d;
  return COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit)
}

function IMEXP(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return exponential of complex number
  const e = Math.exp(x);
  return COMPLEX(e * Math.cos(y), e * Math.sin(y), unit)
}

function IMLN(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return exponential of complex number
  return COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit)
}

function IMLOG10(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return exponential of complex number
  return COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit)
}

function IMLOG2(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return exponential of complex number
  return COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit)
}

function IMPOWER(inumber, number) {
  number = parseNumber(number);
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(number, x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Calculate power of modulus
  const p = Math.pow(IMABS(inumber), number);

  // Calculate argument
  const t = IMARGUMENT(inumber);

  // Return exponential of complex number
  return COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit)
}

function IMPRODUCT() {
  // Initialize result
  let result = arguments[0];

  if (!arguments.length) {
    return value
  }

  // Loop on all numbers
  for (let i = 1; i < arguments.length; i++) {
    // Lookup coefficients of two complex numbers
    const a = IMREAL(result);
    const b = IMAGINARY(result);
    const c = IMREAL(arguments[i]);
    const d = IMAGINARY(arguments[i]);

    if (anyIsError(a, b, c, d)) {
      return value
    }

    // Complute product of two complex numbers
    result = COMPLEX(a * c - b * d, a * d + b * c);
  }

  // Return product of complex numbers
  return result
}

function IMREAL(inumber) {
  if (inumber === undefined || inumber === true || inumber === false) {
    return value
  }

  // Return 0 if inumber is equal to 0
  if (inumber === 0 || inumber === '0') {
    return 0
  }

  // Handle special cases
  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
    return 0
  }

  // Force String type
  inumber = inumber + '';

  // Lookup sign
  let plus = inumber.indexOf('+');
  let minus = inumber.indexOf('-');

  if (plus === 0) {
    plus = inumber.indexOf('+', 1);
  }

  if (minus === 0) {
    minus = inumber.indexOf('-', 1);
  }

  // Lookup imaginary unit
  const last = inumber.substring(inumber.length - 1, inumber.length);
  const unit = last === 'i' || last === 'j';

  if (plus >= 0 || minus >= 0) {
    // Return error if imaginary unit is neither i nor j
    if (!unit) {
      return num
    }

    // Return real coefficient of complex number
    if (plus >= 0) {
      return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))
        ? num
        : Number(inumber.substring(0, plus))
    } else {
      return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))
        ? num
        : Number(inumber.substring(0, minus))
    }
  } else {
    if (unit) {
      return isNaN(inumber.substring(0, inumber.length - 1)) ? num : 0
    } else {
      return isNaN(inumber) ? num : inumber
    }
  }
}

function IMSEC(inumber) {
  // Return error if inumber is a logical value
  if (inumber === true || inumber === false) {
    return value
  }

  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Return secant of complex number
  return IMDIV('1', IMCOS(inumber))
}

function IMSECH(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Return hyperbolic secant of complex number
  return IMDIV('1', IMCOSH(inumber))
}

function IMSIN(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return sine of complex number
  return COMPLEX(
    (Math.sin(x) * (Math.exp(y) + Math.exp(-y))) / 2,
    (Math.cos(x) * (Math.exp(y) - Math.exp(-y))) / 2,
    unit
  )
}

function IMSINH(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Return hyperbolic sine of complex number
  return COMPLEX(
    (Math.cos(y) * (Math.exp(x) - Math.exp(-x))) / 2,
    (Math.sin(y) * (Math.exp(x) + Math.exp(-x))) / 2,
    unit
  )
}

function IMSQRT(inumber) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Lookup imaginary unit
  let unit = inumber.substring(inumber.length - 1);
  unit = unit === 'i' || unit === 'j' ? unit : 'i';

  // Calculate power of modulus
  const s = Math.sqrt(IMABS(inumber));

  // Calculate argument
  const t = IMARGUMENT(inumber);

  // Return exponential of complex number
  return COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit)
}

function IMCSC(inumber) {
  // Return error if inumber is a logical value
  if (inumber === true || inumber === false) {
    return value
  }

  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  // Return error if either coefficient is not a number
  if (anyIsError(x, y)) {
    return num
  }

  // Return cosecant of complex number
  return IMDIV('1', IMSIN(inumber))
}

function IMCSCH(inumber) {
  // Return error if inumber is a logical value
  if (inumber === true || inumber === false) {
    return value
  }

  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  // Return error if either coefficient is not a number
  if (anyIsError(x, y)) {
    return num
  }

  // Return hyperbolic cosecant of complex number
  return IMDIV('1', IMSINH(inumber))
}

function IMSUB(inumber1, inumber2) {
  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const a = IMREAL(inumber1);
  const b = IMAGINARY(inumber1);
  const c = IMREAL(inumber2);
  const d = IMAGINARY(inumber2);

  if (anyIsError(a, b, c, d)) {
    return value
  }

  // Lookup imaginary unit
  const unit1 = inumber1.substring(inumber1.length - 1);
  const unit2 = inumber2.substring(inumber2.length - 1);
  let unit = 'i';

  if (unit1 === 'j') {
    unit = 'j';
  } else if (unit2 === 'j') {
    unit = 'j';
  }

  // Return _ of two complex numbers
  return COMPLEX(a - c, b - d, unit)
}

function IMSUM() {
  if (!arguments.length) {
    return value
  }

  const args = flatten(arguments);

  // Initialize result
  let result = args[0];

  // Loop on all numbers
  for (let i = 1; i < args.length; i++) {
    // Lookup coefficients of two complex numbers
    const a = IMREAL(result);
    const b = IMAGINARY(result);
    const c = IMREAL(args[i]);
    const d = IMAGINARY(args[i]);

    if (anyIsError(a, b, c, d)) {
      return value
    }

    // Complute product of two complex numbers
    result = COMPLEX(a + c, b + d);
  }

  // Return sum of complex numbers
  return result
}

function IMTAN(inumber) {
  // Return error if inumber is a logical value
  if (inumber === true || inumber === false) {
    return value
  }

  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
  const x = IMREAL(inumber);
  const y = IMAGINARY(inumber);

  if (anyIsError(x, y)) {
    return value
  }

  // Return tangent of complex number
  return IMDIV(IMSIN(inumber), IMCOS(inumber))
}

function OCT2BIN(number, places) {
  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
  if (!/^[0-7]{1,10}$/.test(number)) {
    return num
  }

  // Check if number is negative
  const negative = !!(number.length === 10 && number.substring(0, 1) === '7');

  // Convert octal number to decimal
  const decimal = negative ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);

  // Return error if number is lower than -512 or greater than 511
  if (decimal < -512 || decimal > 511) {
    return num
  }

  // Ignore places and return a 10-character binary number if number is negative
  if (negative) {
    return '1' + REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2)
  }

  // Convert decimal number to binary
  const result = decimal.toString(2);

  // Return binary number using the minimum number of characters necessary if places is undefined
  if (typeof places === 'undefined') {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

function OCT2DEC(number) {
  // Return error if number is not octal or contains more than ten characters (10 digits)
  if (!/^[0-7]{1,10}$/.test(number)) {
    return num
  }

  // Convert octal number to decimal
  const decimal = parseInt(number, 8);

  // Return decimal number
  return decimal >= 536870912 ? decimal - 1073741824 : decimal
}

function OCT2HEX(number, places) {
  // Return error if number is not octal or contains more than ten characters (10 digits)
  if (!/^[0-7]{1,10}$/.test(number)) {
    return num
  }

  // Convert octal number to decimal
  const decimal = parseInt(number, 8);

  // Ignore places and return a 10-character octal number if number is negative
  if (decimal >= 536870912) {
    return 'ff' + (decimal + 3221225472).toString(16)
  }

  // Convert decimal number to hexadecimal
  const result = decimal.toString(16);

  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
  if (places === undefined) {
    return result
  } else {
    // Return error if places is nonnumeric
    if (isNaN(places)) {
      return value
    }

    // Return error if places is negative
    if (places < 0) {
      return num
    }

    // Truncate places in case it is not an integer
    places = Math.floor(places);

    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
    return places >= result.length ? REPT('0', places - result.length) + result : num
  }
}

const defaultOperator = '=';
const validSymbols = ['>', '>=', '<', '<=', '=', '<>'];
const _TOKEN_TYPE_OPERATOR = 'operator';
const _TOKEN_TYPE_LITERAL = 'literal';
const SUPPORTED_TOKENS = [_TOKEN_TYPE_OPERATOR, _TOKEN_TYPE_LITERAL];

const TOKEN_TYPE_OPERATOR = _TOKEN_TYPE_OPERATOR;
const TOKEN_TYPE_LITERAL = _TOKEN_TYPE_LITERAL;

/**
 * Create token which describe passed symbol/value.
 *
 * @param {String} value Value/Symbol to describe.
 * @param {String} type Type of the token 'operator' or 'literal'.
 * @
return {Object}
 */
function createToken(value, type) {
  if (SUPPORTED_TOKENS.indexOf(type) === -1) {
    throw new Error('Unsupported token type: ' + type)
  }

  return {
    value: value,
    type: type
  }
}

/**
 * Tries to cast numeric values to their type passed as a string.
 *
 * @param {*} value
 * @
return {*}
 */
function castValueToCorrectType(value) {
  if (typeof value !== 'string') {
    return value
  }

  if (/^\d+(\.\d+)?$/.test(value)) {
    value = value.indexOf('.') === -1 ? parseInt(value, 10) : parseFloat(value);
  }

  return value
}

/**
 * Generate stream of tokens from passed expression.
 *
 * @param {String} expression
 * @
return {String[]}
 */
function tokenizeExpression(expression) {
  const expressionLength = expression.length;
  const tokens = [];
  let cursorIndex = 0;
  let processedValue = '';
  let processedSymbol = '';

  while (cursorIndex < expressionLength) {
    const char = expression.charAt(cursorIndex);

    switch (char) {
      case '>':
      case '<':
      case '=':
        processedSymbol = processedSymbol + char;

        if (processedValue.length > 0) {
          tokens.push(processedValue);
          processedValue = '';
        }

        break
      default:
        if (processedSymbol.length > 0) {
          tokens.push(processedSymbol);
          processedSymbol = '';
        }

        processedValue = processedValue + char;
        break
    }

    cursorIndex++;
  }

  if (processedValue.length > 0) {
    tokens.push(processedValue);
  }

  if (processedSymbol.length > 0) {
    tokens.push(processedSymbol);
  }

  return tokens
}

/**
 * Analyze and convert tokens to an object which describes their meaning.
 *
 * @param {String[]} tokens
 * @
return {Object[]}
 */
function analyzeTokens(tokens) {
  let literalValue = '';
  const analyzedTokens = [];

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    if (i === 0 && validSymbols.indexOf(token) >= 0) {
      analyzedTokens.push(createToken(token, TOKEN_TYPE_OPERATOR));
    } else {
      literalValue += token;
    }
  }

  if (literalValue.length > 0) {
    analyzedTokens.push(createToken(castValueToCorrectType(literalValue), TOKEN_TYPE_LITERAL));
  }

  if (analyzedTokens.length > 0 && analyzedTokens[0].type !== TOKEN_TYPE_OPERATOR) {
    analyzedTokens.unshift(createToken(defaultOperator, TOKEN_TYPE_OPERATOR));
  }

  return analyzedTokens
}

/**
 * Compute/Evaluate an expression passed as an array of tokens.
 *
 * @param {Object[]} tokens
 * @
return {Boolean}
 */
function computeExpression(tokens) {
  const values = [];
  let operator;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    switch (token.type) {
      case TOKEN_TYPE_OPERATOR:
        operator = token.value;
        break
      case TOKEN_TYPE_LITERAL:
        values.push(token.value);
        break
    }
  }

  return evaluate(values, operator)
}

/**
 * Evaluate values based on passed math operator.
 *
 * @param {*} values
 * @param {String} operator
 * @
return {Boolean}
 */
function evaluate(values, operator) {
  let result = false;

  switch (operator) {
    case '>':
      result = values[0] > values[1];
      break
    case '>=':
      result = values[0] >= values[1];
      break
    case '<':
      result = values[0] < values[1];
      break
    case '<=':
      result = values[0] <= values[1];
      break
    case '=':
      result = values[0] == values[1];
      break
    case '<>':
      result = values[0] != values[1];
      break
  }

  return result
}

function parse(expression) {
  return analyzeTokens(tokenizeExpression(expression))
}

const compute = computeExpression;

// TODO
function CELL() {
  throw new Error('CELL is not implemented')
}

const ERROR = {};

ERROR.TYPE = (error_val) => {
  switch (error_val) {
    case nil:
      return 1
    case div0:
      return 2
    case value:
      return 3
    case ref:
      return 4
    case name:
      return 5
    case num:
      return 6
    case na:
      return 7
    case data:
      return 8
  }

  return na
};

// TODO
function INFO() {
  throw new Error('INFO is not implemented')
}

function ISBLANK(value) {
  return value === null
}

function ISBINARY(number) {
  return /^[01]{1,10}$/.test(number)
}

function ISERR(value$1) {
  return (
    [value, ref, div0, num, name, nil].indexOf(value$1) >= 0 ||
    (typeof value$1 === 'number' && (isNaN(value$1) || !isFinite(value$1)))
  )
}

function ISERROR(value) {
  return ISERR(value) || value === na
}

function ISEVEN(number) {
  return !(Math.floor(Math.abs(number)) & 1)
}

// TODO
function ISFORMULA() {
  throw new Error('ISFORMULA is not implemented')
}

function ISLOGICAL(value) {
  return value === true || value === false
}

function ISNA(value) {
  return value === na
}

function ISNONTEXT(value) {
  return typeof value !== 'string'
}

function ISNUMBER(value) {
  return typeof value === 'number' && !isNaN(value) && isFinite(value)
}

function ISODD(number) {
  return !!(Math.floor(Math.abs(number)) & 1)
}

// TODO
function ISREF() {
  throw new Error('ISREF is not implemented')
}

function ISTEXT(value) {
  return typeof value === 'string'
}

function N(value) {
  if (ISNUMBER(value)) {
    return value
  }

  if (value instanceof Date) {
    return value.getTime()
  }

  if (value === true) {
    return 1
  }

  if (value === false) {
    return 0
  }

  if (ISERROR(value)) {
    return value
  }

  return 0
}

function NA() {
  return na
}

// TODO
function SHEET() {
  throw new Error('SHEET is not implemented')
}

// TODO
function SHEETS() {
  throw new Error('SHEETS is not implemented')
}

function TYPE(value) {
  if (ISNUMBER(value)) {
    return 1
  }

  if (ISTEXT(value)) {
    return 2
  }

  if (ISLOGICAL(value)) {
    return 4
  }

  if (ISERROR(value)) {
    return 16
  }

  if (Array.isArray(value)) {
    return 64
  }
}

function UNIQUE() {
  const result = [];

  for (let i = 0; i < arguments.length; ++i) {
    let hasElement = false;
    const element = arguments[i];

    // Check if we've already seen this element.

    for (let j = 0; j < result.length; ++j) {
      hasElement = result[j] === element;

      if (hasElement) {
        break
      }
    }

    // If we did not find it, add it to the result.
    if (!hasElement) {
      result.push(element);
    }
  }

  return result
}

const FLATTEN = flatten;

function ARGS2ARRAY() {
  return Array.prototype.slice.call(arguments, 0)
}

function REFERENCE(context, reference) {
  if (!arguments.length) {
    return error
  }

  try {
    const path = reference.split('.');
    let result = context;

    for (let i = 0; i < path.length; ++i) {
      const step = path[i];

      if (step[step.length - 1] === ']') {
        const opening = step.indexOf('[');
        const index = step.substring(opening + 1, step.length - 1);
        result = result[step.substring(0, opening)][index];
      } else {
        result = result[step];
      }
    }

    return result
  } catch (error) {}
}

function JOIN(array, separator) {
  return array.join(separator)
}

function NUMBERS() {
  const possibleNumbers = flatten(arguments);

  return possibleNumbers.filter((el) => typeof el === 'number')
}

const SQRT2PI = 2.5066282746310002;

function AVEDEV() {
  const flatArguments = flatten(arguments);
  const flatArgumentsDefined = flatArguments.filter(isDefined);

  if (flatArgumentsDefined.length === 0) {
    return num
  }

  const range = parseNumberArray(flatArgumentsDefined);

  if (range instanceof Error) {
    return range
  }

  return jStat__default["default"].sum(jStat__default["default"](range).subtract(jStat__default["default"].mean(range)).abs()[0]) / range.length
}

function AVERAGE() {
  const flatArguments = flatten(arguments);
  const flatArgumentsDefined = flatArguments.filter(isDefined);

  if (flatArgumentsDefined.length === 0) {
    return div0
  }

  const someError = anyError.apply(undefined, flatArgumentsDefined);

  if (someError) {
    return someError
  }

  const range = numbers(flatArgumentsDefined);
  const n = range.length;
  let sum = 0;
  let count = 0;
  let result;

  for (let i = 0; i < n; i++) {
    sum += range[i];
    count += 1;
  }

  result = sum / count;

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function AVERAGEA() {
  const flatArguments = flatten(arguments);
  const flatArgumentsDefined = flatArguments.filter(isDefined);

  if (flatArgumentsDefined.length === 0) {
    return div0
  }

  const someError = anyError.apply(undefined, flatArgumentsDefined);

  if (someError) {
    return someError
  }

  const range = flatArgumentsDefined;
  const n = range.length;
  let sum = 0;
  let count = 0;
  let result;

  for (let i = 0; i < n; i++) {
    const el = range[i];

    if (typeof el === 'number') {
      sum += el;
    }

    if (el === true) {
      sum++;
    }

    if (el !== null) {
      count++;
    }
  }

  result = sum / count;

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function AVERAGEIF(range, criteria, average_range) {
  if (arguments.length <= 1) {
    return na
  }

  average_range = average_range || range;
  const flatAverageRange = flatten(average_range);
  const flatAverageRangeDefined = flatAverageRange.filter(isDefined);
  average_range = parseNumberArray(flatAverageRangeDefined);

  range = flatten(range);

  if (average_range instanceof Error) {
    return average_range
  }

  let average_count = 0;
  let result = 0;
  const isWildcard = criteria === void 0 || criteria === '*';
  const tokenizedCriteria = isWildcard ? null : parse(criteria + '');

  for (let i = 0; i < range.length; i++) {
    const value = range[i];

    if (isWildcard) {
      result += average_range[i];
      average_count++;
    } else {
      const tokens = [createToken(value, TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);

      if (compute(tokens)) {
        result += average_range[i];
        average_count++;
      }
    }
  }

  return result / average_count
}

function AVERAGEIFS() {
  // Does not work with multi dimensional ranges yet!
  // http://office.microsoft.com/en-001/excel-help/averageifs-function-HA010047493.aspx
  const args = argsToArray(arguments);
  const criteriaLength = (args.length - 1) / 2;
  const range = flatten(args[0]);
  let count = 0;
  let result = 0;

  for (let i = 0; i < range.length; i++) {
    let isMeetCondition = false;

    for (let j = 0; j < criteriaLength; j++) {
      const value = args[2 * j + 1][i];
      const criteria = args[2 * j + 2];
      const isWildcard = criteria === void 0 || criteria === '*';
      let computedResult = false;

      if (isWildcard) {
        computedResult = true;
      } else {
        const tokenizedCriteria = parse(criteria + '');
        const tokens = [createToken(value, TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);

        computedResult = compute(tokens);
      }

      // Criterias are calculated as AND so any `false` breakes the loop as unmeet condition
      if (!computedResult) {
        isMeetCondition = false;
        break
      }

      isMeetCondition = true;
    }

    if (isMeetCondition) {
      result += range[i];
      count++;
    }
  }

  const average = result / count;

  if (isNaN(average)) {
    return 0
  } else {
    return average
  }
}

const BETA = {};

BETA.DIST = function (x, alpha, beta, cumulative, A, B) {
  if (arguments.length < 4) {
    return value
  }

  A = A === undefined ? 0 : A;
  B = B === undefined ? 1 : B;

  x = parseNumber(x);
  alpha = parseNumber(alpha);
  beta = parseNumber(beta);
  A = parseNumber(A);
  B = parseNumber(B);

  if (anyIsError(x, alpha, beta, A, B)) {
    return value
  }

  x = (x - A) / (B - A);

  return cumulative ? jStat__default["default"].beta.cdf(x, alpha, beta) : jStat__default["default"].beta.pdf(x, alpha, beta)
};

BETA.INV = (probability, alpha, beta, A, B) => {
  A = A === undefined ? 0 : A;
  B = B === undefined ? 1 : B;

  probability = parseNumber(probability);
  alpha = parseNumber(alpha);
  beta = parseNumber(beta);
  A = parseNumber(A);
  B = parseNumber(B);

  if (anyIsError(probability, alpha, beta, A, B)) {
    return value
  }

  return jStat__default["default"].beta.inv(probability, alpha, beta) * (B - A) + A
};

const BINOM = {};

BINOM.DIST = (successes, trials, probability, cumulative) => {
  successes = parseNumber(successes);
  trials = parseNumber(trials);
  probability = parseNumber(probability);
  cumulative = parseNumber(cumulative);

  if (anyIsError(successes, trials, probability, cumulative)) {
    return value
  }

  return cumulative
    ? jStat__default["default"].binomial.cdf(successes, trials, probability)
    : jStat__default["default"].binomial.pdf(successes, trials, probability)
};

BINOM.DIST.RANGE = (trials, probability, successes, successes2) => {
  successes2 = successes2 === undefined ? successes : successes2;

  trials = parseNumber(trials);
  probability = parseNumber(probability);
  successes = parseNumber(successes);
  successes2 = parseNumber(successes2);

  if (anyIsError(trials, probability, successes, successes2)) {
    return value
  }

  let result = 0;

  for (let i = successes; i <= successes2; i++) {
    result += COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);
  }

  return result
};

BINOM.INV = (trials, probability, alpha) => {
  trials = parseNumber(trials);
  probability = parseNumber(probability);
  alpha = parseNumber(alpha);

  if (anyIsError(trials, probability, alpha)) {
    return value
  }

  let x = 0;

  while (x <= trials) {
    if (jStat__default["default"].binomial.cdf(x, trials, probability) >= alpha) {
      return x
    }

    x++;
  }
};

const CHISQ = {};

CHISQ.DIST = (x, k, cumulative) => {
  x = parseNumber(x);
  k = parseNumber(k);

  if (anyIsError(x, k)) {
    return value
  }

  return cumulative ? jStat__default["default"].chisquare.cdf(x, k) : jStat__default["default"].chisquare.pdf(x, k)
};

CHISQ.DIST.RT = (x, k) => {
  if (!x | !k) {
    return na
  }

  if (x < 1 || k > Math.pow(10, 10)) {
    return num
  }

  if (typeof x !== 'number' || typeof k !== 'number') {
    return value
  }

  return 1 - jStat__default["default"].chisquare.cdf(x, k)
};

CHISQ.INV = (probability, k) => {
  probability = parseNumber(probability);
  k = parseNumber(k);

  if (anyIsError(probability, k)) {
    return value
  }

  return jStat__default["default"].chisquare.inv(probability, k)
};

CHISQ.INV.RT = (p, k) => {
  if (!p | !k) {
    return na
  }

  if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {
    return num
  }

  if (typeof p !== 'number' || typeof k !== 'number') {
    return value
  }

  return jStat__default["default"].chisquare.inv(1.0 - p, k)
};

CHISQ.TEST = function (observed, expected) {
  if (arguments.length !== 2) {
    return na
  }

  if (!(observed instanceof Array) || !(expected instanceof Array)) {
    return value
  }

  if (observed.length !== expected.length) {
    return value
  }

  if (observed[0] && expected[0] && observed[0].length !== expected[0].length) {
    return value
  }

  const row = observed.length;
  let tmp, i, j;

  // Convert single-dimension array into two-dimension array

  for (i = 0; i < row; i++) {
    if (!(observed[i] instanceof Array)) {
      tmp = observed[i];
      observed[i] = [];
      observed[i].push(tmp);
    }

    if (!(expected[i] instanceof Array)) {
      tmp = expected[i];
      expected[i] = [];
      expected[i].push(tmp);
    }
  }

  const col = observed[0].length;
  const dof = col === 1 ? row - 1 : (row - 1) * (col - 1);
  let xsqr = 0;
  const Pi = Math.PI;

  for (i = 0; i < row; i++) {
    for (j = 0; j < col; j++) {
      xsqr += Math.pow(observed[i][j] - expected[i][j], 2) / expected[i][j];
    }
  }

  // Get independency by X square and its degree of freedom
  function ChiSq(xsqr, dof) {
    let p = Math.exp(-0.5 * xsqr);

    if (dof % 2 === 1) {
      p = p * Math.sqrt((2 * xsqr) / Pi);
    }

    let k = dof;

    while (k >= 2) {
      p = (p * xsqr) / k;
      k = k - 2;
    }

    let t = p;
    let a = dof;

    while (t > 0.0000000001 * p) {
      a = a + 2;
      t = (t * xsqr) / a;
      p = p + t;
    }

    return 1 - p
  }

  return Math.round(ChiSq(xsqr, dof) * 1000000) / 1000000
};

function COLUMN(matrix, index) {
  if (arguments.length !== 2) {
    return na
  }

  if (index < 0) {
    return num
  }

  if (!(matrix instanceof Array) || typeof index !== 'number') {
    return value
  }

  if (matrix.length === 0) {
    return undefined
  }

  return jStat__default["default"].col(matrix, index)
}

function COLUMNS(matrix) {
  if (arguments.length !== 1) {
    return na
  }

  if (!(matrix instanceof Array)) {
    return value
  }

  if (matrix.length === 0) {
    return 0
  }

  return jStat__default["default"].cols(matrix)
}

const CONFIDENCE = {};

CONFIDENCE.NORM = (alpha, sd, n) => {
  alpha = parseNumber(alpha);
  sd = parseNumber(sd);
  n = parseNumber(n);

  if (anyIsError(alpha, sd, n)) {
    return value
  }

  return jStat__default["default"].normalci(1, alpha, sd, n)[1] - 1
};

CONFIDENCE.T = (alpha, sd, n) => {
  alpha = parseNumber(alpha);
  sd = parseNumber(sd);
  n = parseNumber(n);

  if (anyIsError(alpha, sd, n)) {
    return value
  }

  return jStat__default["default"].tci(1, alpha, sd, n)[1] - 1
};

function CORREL(array1, array2) {
  array1 = parseNumberArray(flatten(array1));
  array2 = parseNumberArray(flatten(array2));

  if (anyIsError(array1, array2)) {
    return value
  }

  return jStat__default["default"].corrcoeff(array1, array2)
}

function COUNT() {
  const flatArguments = flatten(arguments);

  return numbers(flatArguments).length
}

function COUNTA() {
  const flatArguments = flatten(arguments);

  return flatArguments.length - COUNTBLANK(flatArguments)
}

function COUNTIN(range, value) {
  let result = 0;

  range = flatten(range);

  for (let i = 0; i < range.length; i++) {
    if (range[i] === value) {
      result++;
    }
  }

  return result
}

function COUNTBLANK() {
  const range = flatten(arguments);
  let blanks = 0;
  let element;

  for (let i = 0; i < range.length; i++) {
    element = range[i];

    if (element === undefined || element === null || element === '') {
      blanks++;
    }
  }

  return blanks
}

function COUNTIF(range, criteria) {
  range = flatten(range);

  const isWildcard = criteria === void 0 || criteria === '*';

  if (isWildcard) {
    return range.length
  }

  let matches = 0;
  const tokenizedCriteria = parse(criteria + '');

  for (let i = 0; i < range.length; i++) {
    const value = range[i];
    const tokens = [createToken(value, TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);

    if (compute(tokens)) {
      matches++;
    }
  }

  return matches
}

function COUNTIFS() {
  const args = argsToArray(arguments);
  const results = new Array(flatten(args[0]).length);

  for (let i = 0; i < results.length; i++) {
    results[i] = true;
  }

  for (let i = 0; i < args.length; i += 2) {
    const range = flatten(args[i]);
    const criteria = args[i + 1];
    const isWildcard = criteria === void 0 || criteria === '*';

    if (!isWildcard) {
      const tokenizedCriteria = parse(criteria + '');

      for (let j = 0; j < range.length; j++) {
        const value = range[j];
        const tokens = [createToken(value, TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);

        results[j] = results[j] && compute(tokens);
      }
    }
  }

  let result = 0;

  for (let i = 0; i < results.length; i++) {
    if (results[i]) {
      result++;
    }
  }

  return result
}

function COUNTUNIQUE() {
  return UNIQUE.apply(null, flatten(arguments)).length
}

const COVARIANCE = {};

COVARIANCE.P = (array1, array2) => {
  array1 = parseNumberArray(flatten(array1));
  array2 = parseNumberArray(flatten(array2));

  if (anyIsError(array1, array2)) {
    return value
  }

  const mean1 = jStat__default["default"].mean(array1);
  const mean2 = jStat__default["default"].mean(array2);
  let result = 0;
  const n = array1.length;

  for (let i = 0; i < n; i++) {
    result += (array1[i] - mean1) * (array2[i] - mean2);
  }

  return result / n
};

COVARIANCE.S = (array1, array2) => {
  array1 = parseNumberArray(flatten(array1));
  array2 = parseNumberArray(flatten(array2));

  if (anyIsError(array1, array2)) {
    return value
  }

  return jStat__default["default"].covariance(array1, array2)
};

function DEVSQ() {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const mean = jStat__default["default"].mean(range);
  let result = 0;

  for (let i = 0; i < range.length; i++) {
    result += Math.pow(range[i] - mean, 2);
  }

  return result
}

const EXPON = {};

EXPON.DIST = (x, lambda, cumulative) => {
  x = parseNumber(x);
  lambda = parseNumber(lambda);

  if (anyIsError(x, lambda)) {
    return value
  }

  return cumulative ? jStat__default["default"].exponential.cdf(x, lambda) : jStat__default["default"].exponential.pdf(x, lambda)
};

const F = {};

F.DIST = (x, d1, d2, cumulative) => {
  x = parseNumber(x);
  d1 = parseNumber(d1);
  d2 = parseNumber(d2);

  if (anyIsError(x, d1, d2)) {
    return value
  }

  return cumulative ? jStat__default["default"].centralF.cdf(x, d1, d2) : jStat__default["default"].centralF.pdf(x, d1, d2)
};

F.DIST.RT = function (x, d1, d2) {
  if (arguments.length !== 3) {
    return na
  }

  if (x < 0 || d1 < 1 || d2 < 1) {
    return num
  }

  if (typeof x !== 'number' || typeof d1 !== 'number' || typeof d2 !== 'number') {
    return value
  }

  return 1 - jStat__default["default"].centralF.cdf(x, d1, d2)
};

F.INV = (probability, d1, d2) => {
  probability = parseNumber(probability);
  d1 = parseNumber(d1);
  d2 = parseNumber(d2);

  if (anyIsError(probability, d1, d2)) {
    return value
  }

  if (probability <= 0.0 || probability > 1.0) {
    return num
  }

  return jStat__default["default"].centralF.inv(probability, d1, d2)
};

F.INV.RT = function (p, d1, d2) {
  if (arguments.length !== 3) {
    return na
  }

  if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
    return num
  }

  if (typeof p !== 'number' || typeof d1 !== 'number' || typeof d2 !== 'number') {
    return value
  }

  return jStat__default["default"].centralF.inv(1.0 - p, d1, d2)
};

F.TEST = (array1, array2) => {
  if (!array1 || !array2) {
    return na
  }

  if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
    return na
  }

  if (array1.length < 2 || array2.length < 2) {
    return div0
  }

  const sumOfSquares = (values, x1) => {
    let sum = 0;

    for (let i = 0; i < values.length; i++) {
      sum += Math.pow(values[i] - x1, 2);
    }

    return sum
  };

  const x1 = SUM(array1) / array1.length;
  const x2 = SUM(array2) / array2.length;
  const sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
  const sum2 = sumOfSquares(array2, x2) / (array2.length - 1);

  return sum1 / sum2
};

function FISHER(x) {
  x = parseNumber(x);

  if (x instanceof Error) {
    return x
  }

  return Math.log((1 + x) / (1 - x)) / 2
}

function FISHERINV(y) {
  y = parseNumber(y);

  if (y instanceof Error) {
    return y
  }

  const e2y = Math.exp(2 * y);

  return (e2y - 1) / (e2y + 1)
}

function FORECAST(x, data_y, data_x) {
  x = parseNumber(x);
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));

  if (anyIsError(x, data_y, data_x)) {
    return value
  }

  const xmean = jStat__default["default"].mean(data_x);
  const ymean = jStat__default["default"].mean(data_y);
  const n = data_x.length;
  let num = 0;
  let den = 0;

  for (let i = 0; i < n; i++) {
    num += (data_x[i] - xmean) * (data_y[i] - ymean);
    den += Math.pow(data_x[i] - xmean, 2);
  }

  const b = num / den;
  const a = ymean - b * xmean;

  return a + b * x
}

function FREQUENCY(data, bins) {
  data = parseNumberArray(flatten(data));
  bins = parseNumberArray(flatten(bins));

  if (anyIsError(data, bins)) {
    return value
  }

  const n = data.length;
  const b = bins.length;
  const r = [];

  for (let i = 0; i <= b; i++) {
    r[i] = 0;

    for (let j = 0; j < n; j++) {
      if (i === 0) {
        if (data[j] <= bins[0]) {
          r[0] += 1;
        }
      } else if (i < b) {
        if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
          r[i] += 1;
        }
      } else if (i === b) {
        if (data[j] > bins[b - 1]) {
          r[b] += 1;
        }
      }
    }
  }

  return r
}

function GAMMA(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return num
  }

  if (parseInt(number, 10) === number && number < 0) {
    return num
  }

  return jStat__default["default"].gammafn(number)
}

GAMMA.DIST = function (value$1, alpha, beta, cumulative) {
  if (arguments.length !== 4) {
    return na
  }

  if (value$1 < 0 || alpha <= 0 || beta <= 0) {
    return value
  }

  if (typeof value$1 !== 'number' || typeof alpha !== 'number' || typeof beta !== 'number') {
    return value
  }

  return cumulative ? jStat__default["default"].gamma.cdf(value$1, alpha, beta, true) : jStat__default["default"].gamma.pdf(value$1, alpha, beta, false)
};

GAMMA.INV = function (probability, alpha, beta) {
  if (arguments.length !== 3) {
    return na
  }

  if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
    return num
  }

  if (typeof probability !== 'number' || typeof alpha !== 'number' || typeof beta !== 'number') {
    return value
  }

  return jStat__default["default"].gamma.inv(probability, alpha, beta)
};

function GAMMALN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return jStat__default["default"].gammaln(number)
}

GAMMALN.PRECISE = function (x) {
  if (arguments.length !== 1) {
    return na
  }

  if (x <= 0) {
    return num
  }

  if (typeof x !== 'number') {
    return value
  }

  return jStat__default["default"].gammaln(x)
};

function GAUSS(z) {
  z = parseNumber(z);

  if (z instanceof Error) {
    return z
  }

  return jStat__default["default"].normal.cdf(z, 0, 1) - 0.5
}

function GEOMEAN() {
  const args = parseNumberArray(flatten(arguments));

  if (args instanceof Error) {
    return args
  }

  return jStat__default["default"].geomean(args)
}

function GROWTH(known_y, known_x, new_x, use_const) {
  // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)
  known_y = parseNumberArray(known_y);

  if (known_y instanceof Error) {
    return known_y
  }

  // Default values for optional parameters:
  let i;

  if (known_x === undefined) {
    known_x = [];

    for (i = 1; i <= known_y.length; i++) {
      known_x.push(i);
    }
  }

  if (new_x === undefined) {
    new_x = [];

    for (i = 1; i <= known_y.length; i++) {
      new_x.push(i);
    }
  }

  known_x = parseNumberArray(known_x);
  new_x = parseNumberArray(new_x);

  if (anyIsError(known_x, new_x)) {
    return value
  }

  if (use_const === undefined) {
    use_const = true;
  }

  // Calculate sums over the data:
  const n = known_y.length;
  let avg_x = 0;
  let avg_y = 0;
  let avg_xy = 0;
  let avg_xx = 0;

  for (i = 0; i < n; i++) {
    const x = known_x[i];
    const y = Math.log(known_y[i]);
    avg_x += x;
    avg_y += y;
    avg_xy += x * y;
    avg_xx += x * x;
  }

  avg_x /= n;
  avg_y /= n;
  avg_xy /= n;
  avg_xx /= n;

  // Compute linear regression coefficients:
  let beta;
  let alpha;

  if (use_const) {
    beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
    alpha = avg_y - beta * avg_x;
  } else {
    beta = avg_xy / avg_xx;
    alpha = 0;
  }

  // Compute and return result array:
  const new_y = [];

  for (i = 0; i < new_x.length; i++) {
    new_y.push(Math.exp(alpha + beta * new_x[i]));
  }

  return new_y
}

function HARMEAN() {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const n = range.length;
  let den = 0;

  for (let i = 0; i < n; i++) {
    den += 1 / range[i];
  }

  return n / den
}

const HYPGEOM = {};

HYPGEOM.DIST = (x, n, M, N, cumulative) => {
  x = parseNumber(x);
  n = parseNumber(n);
  M = parseNumber(M);
  N = parseNumber(N);

  if (anyIsError(x, n, M, N)) {
    return value
  }

  function pdf(x, n, M, N) {
    return (COMBIN(M, x) * COMBIN(N - M, n - x)) / COMBIN(N, n)
  }

  function cdf(x, n, M, N) {
    let result = 0;

    for (let i = 0; i <= x; i++) {
      result += pdf(i, n, M, N);
    }

    return result
  }

  return cumulative ? cdf(x, n, M, N) : pdf(x, n, M, N)
};

function INTERCEPT(known_y, known_x) {
  known_y = parseNumberArray(known_y);
  known_x = parseNumberArray(known_x);

  if (anyIsError(known_y, known_x)) {
    return value
  }

  if (known_y.length !== known_x.length) {
    return na
  }

  return FORECAST(0, known_y, known_x)
}

function KURT() {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const mean = jStat__default["default"].mean(range);
  const n = range.length;
  let sigma = 0;

  for (let i = 0; i < n; i++) {
    sigma += Math.pow(range[i] - mean, 4);
  }

  sigma = sigma / Math.pow(jStat__default["default"].stdev(range, true), 4);

  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3))
}

function LARGE(range, k) {
  range = parseNumberArray(flatten(range));
  k = parseNumber(k);

  if (anyIsError(range, k)) {
    return range
  }

  if (k < 0 || range.length < k) {
    return value
  }

  return range.sort((a, b) => b - a)[k - 1]
}

function LINEST(data_y, data_x) {
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));

  if (anyIsError(data_y, data_x)) {
    return value
  }

  const ymean = jStat__default["default"].mean(data_y);
  const xmean = jStat__default["default"].mean(data_x);
  const n = data_x.length;
  let num = 0;
  let den = 0;

  for (let i = 0; i < n; i++) {
    num += (data_x[i] - xmean) * (data_y[i] - ymean);
    den += Math.pow(data_x[i] - xmean, 2);
  }

  const m = num / den;
  const b = ymean - m * xmean;

  return [m, b]
}

// According to Microsoft:
// http://office.microsoft.com/en-us/starter-help/logest-function-HP010342665.aspx
// LOGEST returns are based on the following linear model:
// ln y = x1 ln m1 + ... + xn ln mn + ln b
function LOGEST(data_y, data_x) {
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));

  if (anyIsError(data_y, data_x)) {
    return value
  }

  for (let i = 0; i < data_y.length; i++) {
    data_y[i] = Math.log(data_y[i]);
  }

  const result = LINEST(data_y, data_x);
  result[0] = Math.round(Math.exp(result[0]) * 1000000) / 1000000;
  result[1] = Math.round(Math.exp(result[1]) * 1000000) / 1000000;

  return result
}

const LOGNORM = {};

LOGNORM.DIST = (x, mean, sd, cumulative) => {
  x = parseNumber(x);
  mean = parseNumber(mean);
  sd = parseNumber(sd);

  if (anyIsError(x, mean, sd)) {
    return value
  }

  return cumulative ? jStat__default["default"].lognormal.cdf(x, mean, sd) : jStat__default["default"].lognormal.pdf(x, mean, sd)
};

LOGNORM.INV = (probability, mean, sd) => {
  probability = parseNumber(probability);
  mean = parseNumber(mean);
  sd = parseNumber(sd);

  if (anyIsError(probability, mean, sd)) {
    return value
  }

  return jStat__default["default"].lognormal.inv(probability, mean, sd)
};

function MAX() {
  const flatArguments = flatten(arguments);
  const someError = anyError.apply(undefined, flatArguments);

  if (someError) {
    return someError
  }

  const range = numbers(flatArguments);

  return range.length === 0 ? 0 : Math.max.apply(Math, range)
}

function MAXA() {
  const flatArguments = flatten(arguments);
  const someError = anyError.apply(undefined, flatArguments);

  if (someError) {
    return someError
  }

  let range = arrayValuesToNumbers(flatArguments);
  range = range.map((value) => (value === undefined || value === null ? 0 : value));

  return range.length === 0 ? 0 : Math.max.apply(Math, range)
}

function MEDIAN() {
  const flatArguments = flatten(arguments);
  const someError = anyError.apply(undefined, flatArguments);

  if (someError) {
    return someError
  }

  const range = arrayValuesToNumbers(flatArguments);
  let result = jStat__default["default"].median(range);

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function MIN() {
  const flatArguments = flatten(arguments);
  const someError = anyError.apply(undefined, flatArguments);

  if (someError) {
    return someError
  }

  const range = numbers(flatArguments);

  return range.length === 0 ? 0 : Math.min.apply(Math, range)
}

function MINA() {
  const flatArguments = flatten(arguments);
  const someError = anyError.apply(undefined, flatArguments);

  if (someError) {
    return someError
  }

  let range = arrayValuesToNumbers(flatArguments);
  range = range.map((value) => (value === undefined || value === null ? 0 : value));

  return range.length === 0 ? 0 : Math.min.apply(Math, range)
}

const MODE = {};

MODE.MULT = function () {
  // Credits: Roönaän
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const n = range.length;
  const count = {};
  let maxItems = [];
  let max = 0;
  let currentItem;

  for (let i = 0; i < n; i++) {
    currentItem = range[i];
    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;

    if (count[currentItem] > max) {
      max = count[currentItem];
      maxItems = [];
    }

    if (count[currentItem] === max) {
      maxItems[maxItems.length] = currentItem;
    }
  }

  return maxItems
};

MODE.SNGL = function () {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  return MODE.MULT(range).sort((a, b) => a - b)[0]
};

const NEGBINOM = {};

NEGBINOM.DIST = (k, r, p, cumulative) => {
  k = parseNumber(k);
  r = parseNumber(r);
  p = parseNumber(p);

  if (anyIsError(k, r, p)) {
    return value
  }

  return cumulative ? jStat__default["default"].negbin.cdf(k, r, p) : jStat__default["default"].negbin.pdf(k, r, p)
};

const NORM = {};

NORM.DIST = (x, mean, sd, cumulative) => {
  x = parseNumber(x);
  mean = parseNumber(mean);
  sd = parseNumber(sd);

  if (anyIsError(x, mean, sd)) {
    return value
  }

  if (sd <= 0) {
    return num
  }

  // Return normal distribution computed by jStat [http://jstat.org]
  return cumulative ? jStat__default["default"].normal.cdf(x, mean, sd) : jStat__default["default"].normal.pdf(x, mean, sd)
};

NORM.INV = (probability, mean, sd) => {
  probability = parseNumber(probability);
  mean = parseNumber(mean);
  sd = parseNumber(sd);

  if (anyIsError(probability, mean, sd)) {
    return value
  }

  return jStat__default["default"].normal.inv(probability, mean, sd)
};

NORM.S = {};

NORM.S.DIST = (z, cumulative) => {
  z = parseNumber(z);

  if (z instanceof Error) {
    return value
  }

  return cumulative ? jStat__default["default"].normal.cdf(z, 0, 1) : jStat__default["default"].normal.pdf(z, 0, 1)
};

NORM.S.INV = (probability) => {
  probability = parseNumber(probability);

  if (probability instanceof Error) {
    return value
  }

  return jStat__default["default"].normal.inv(probability, 0, 1)
};

function PEARSON(data_x, data_y) {
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));

  if (anyIsError(data_y, data_x)) {
    return value
  }

  const xmean = jStat__default["default"].mean(data_x);
  const ymean = jStat__default["default"].mean(data_y);
  const n = data_x.length;
  let num = 0;
  let den1 = 0;
  let den2 = 0;

  for (let i = 0; i < n; i++) {
    num += (data_x[i] - xmean) * (data_y[i] - ymean);
    den1 += Math.pow(data_x[i] - xmean, 2);
    den2 += Math.pow(data_y[i] - ymean, 2);
  }

  return num / Math.sqrt(den1 * den2)
}

const PERCENTILE = {};

PERCENTILE.EXC = (array, k) => {
  array = parseNumberArray(flatten(array));
  k = parseNumber(k);

  if (anyIsError(array, k)) {
    return value
  }

  array = array.sort((a, b) => a - b);
  const n = array.length;

  if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
    return num
  }

  const l = k * (n + 1) - 1;
  const fl = Math.floor(l);

  return cleanFloat(l === fl ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]))
};

PERCENTILE.INC = (array, k) => {
  array = parseNumberArray(flatten(array));
  k = parseNumber(k);

  if (anyIsError(array, k)) {
    return value
  }

  array = array.sort((a, b) => a - b);
  const n = array.length;
  const l = k * (n - 1);
  const fl = Math.floor(l);

  return cleanFloat(l === fl ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]))
};

const PERCENTRANK = {};

PERCENTRANK.EXC = (array, x, significance) => {
  significance = significance === undefined ? 3 : significance;
  array = parseNumberArray(flatten(array));
  x = parseNumber(x);
  significance = parseNumber(significance);

  if (anyIsError(array, x, significance)) {
    return value
  }

  array = array.sort((a, b) => a - b);
  const uniques = UNIQUE.apply(null, array);
  const n = array.length;
  const m = uniques.length;
  const power = Math.pow(10, significance);
  let result = 0;
  let match = false;
  let i = 0;

  while (!match && i < m) {
    if (x === uniques[i]) {
      result = (array.indexOf(uniques[i]) + 1) / (n + 1);
      match = true;
    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
      result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
      match = true;
    }

    i++;
  }

  return Math.floor(result * power) / power
};

PERCENTRANK.INC = (array, x, significance) => {
  significance = significance === undefined ? 3 : significance;
  array = parseNumberArray(flatten(array));
  x = parseNumber(x);
  significance = parseNumber(significance);

  if (anyIsError(array, x, significance)) {
    return value
  }

  array = array.sort((a, b) => a - b);
  const uniques = UNIQUE.apply(null, array);
  const n = array.length;
  const m = uniques.length;
  const power = Math.pow(10, significance);
  let result = 0;
  let match = false;
  let i = 0;

  while (!match && i < m) {
    if (x === uniques[i]) {
      result = array.indexOf(uniques[i]) / (n - 1);
      match = true;
    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
      result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
      match = true;
    }

    i++;
  }

  return Math.floor(result * power) / power
};

function PERMUT(number, number_chosen) {
  number = parseNumber(number);
  number_chosen = parseNumber(number_chosen);

  if (anyIsError(number, number_chosen)) {
    return value
  }

  return FACT(number) / FACT(number - number_chosen)
}

function PERMUTATIONA(number, number_chosen) {
  number = parseNumber(number);
  number_chosen = parseNumber(number_chosen);

  if (anyIsError(number, number_chosen)) {
    return value
  }

  return Math.pow(number, number_chosen)
}

function PHI(x) {
  x = parseNumber(x);

  if (x instanceof Error) {
    return value
  }

  return Math.exp(-0.5 * x * x) / SQRT2PI
}

const POISSON = {};

POISSON.DIST = (x, mean, cumulative) => {
  x = parseNumber(x);
  mean = parseNumber(mean);

  if (anyIsError(x, mean)) {
    return value
  }

  return cumulative ? jStat__default["default"].poisson.cdf(x, mean) : jStat__default["default"].poisson.pdf(x, mean)
};

function PROB(range, probability, lower, upper) {
  if (lower === undefined) {
    return 0
  }

  upper = upper === undefined ? lower : upper;

  range = parseNumberArray(flatten(range));
  probability = parseNumberArray(flatten(probability));
  lower = parseNumber(lower);
  upper = parseNumber(upper);

  if (anyIsError(range, probability, lower, upper)) {
    return value
  }

  if (lower === upper) {
    return range.indexOf(lower) >= 0 ? probability[range.indexOf(lower)] : 0
  }

  const sorted = range.sort((a, b) => a - b);
  const n = sorted.length;
  let result = 0;

  for (let i = 0; i < n; i++) {
    if (sorted[i] >= lower && sorted[i] <= upper) {
      result += probability[range.indexOf(sorted[i])];
    }
  }

  return result
}

const QUARTILE = {};

QUARTILE.EXC = (range, quart) => {
  range = parseNumberArray(flatten(range));
  quart = parseNumber(quart);

  if (anyIsError(range, quart)) {
    return value
  }

  switch (quart) {
    case 1:
      return PERCENTILE.EXC(range, 0.25)
    case 2:
      return PERCENTILE.EXC(range, 0.5)
    case 3:
      return PERCENTILE.EXC(range, 0.75)
    default:
      return num
  }
};

QUARTILE.INC = (range, quart) => {
  range = parseNumberArray(flatten(range));
  quart = parseNumber(quart);

  if (anyIsError(range, quart)) {
    return value
  }

  switch (quart) {
    case 1:
      return PERCENTILE.INC(range, 0.25)
    case 2:
      return PERCENTILE.INC(range, 0.5)
    case 3:
      return PERCENTILE.INC(range, 0.75)
    default:
      return num
  }
};

const RANK = {};

RANK.AVG = (number, range, order) => {
  number = parseNumber(number);
  range = parseNumberArray(flatten(range));

  if (anyIsError(number, range)) {
    return value
  }

  range = flatten(range);
  order = order || false;
  const sort = order ? (a, b) => a - b : (a, b) => b - a;
  range = range.sort(sort);

  const length = range.length;
  let count = 0;

  for (let i = 0; i < length; i++) {
    if (range[i] === number) {
      count++;
    }
  }

  return count > 1 ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1
};

RANK.EQ = (number, range, order) => {
  number = parseNumber(number);
  range = parseNumberArray(flatten(range));

  if (anyIsError(number, range)) {
    return value
  }

  order = order || false;
  const sort = order ? (a, b) => a - b : (a, b) => b - a;
  range = range.sort(sort);

  return range.indexOf(number) + 1
};

function ROW(matrix, index) {
  if (arguments.length !== 2) {
    return na
  }

  if (index < 0) {
    return num
  }

  if (!(matrix instanceof Array) || typeof index !== 'number') {
    return value
  }

  if (matrix.length === 0) {
    return undefined
  }

  return jStat__default["default"].row(matrix, index)
}

function ROWS(matrix) {
  if (arguments.length !== 1) {
    return na
  }

  if (!(matrix instanceof Array)) {
    return value
  }

  if (matrix.length === 0) {
    return 0
  }

  return jStat__default["default"].rows(matrix)
}

function RSQ(data_x, data_y) {
  // no need to flatten here, PEARSON will take care of that
  data_x = parseNumberArray(flatten(data_x));
  data_y = parseNumberArray(flatten(data_y));

  if (anyIsError(data_x, data_y)) {
    return value
  }

  return Math.pow(PEARSON(data_x, data_y), 2)
}

function SKEW() {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const mean = jStat__default["default"].mean(range);
  const n = range.length;
  let sigma = 0;

  for (let i = 0; i < n; i++) {
    sigma += Math.pow(range[i] - mean, 3);
  }

  return (n * sigma) / ((n - 1) * (n - 2) * Math.pow(jStat__default["default"].stdev(range, true), 3))
}

SKEW.P = function () {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const mean = jStat__default["default"].mean(range);
  const n = range.length;
  let m2 = 0;
  let m3 = 0;

  for (let i = 0; i < n; i++) {
    m3 += Math.pow(range[i] - mean, 3);
    m2 += Math.pow(range[i] - mean, 2);
  }

  m3 = m3 / n;
  m2 = m2 / n;

  return m3 / Math.pow(m2, 3 / 2)
};

function SLOPE(data_y, data_x) {
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));

  if (anyIsError(data_y, data_x)) {
    return value
  }

  const xmean = jStat__default["default"].mean(data_x);
  const ymean = jStat__default["default"].mean(data_y);
  const n = data_x.length;
  let num = 0;
  let den = 0;

  for (let i = 0; i < n; i++) {
    num += (data_x[i] - xmean) * (data_y[i] - ymean);
    den += Math.pow(data_x[i] - xmean, 2);
  }

  return num / den
}

function SMALL(range, k) {
  range = parseNumberArray(flatten(range));
  k = parseNumber(k);

  if (anyIsError(range, k)) {
    return range
  }

  return range.sort((a, b) => a - b)[k - 1]
}

function STANDARDIZE(x, mean, sd) {
  x = parseNumber(x);
  mean = parseNumber(mean);
  sd = parseNumber(sd);

  if (anyIsError(x, mean, sd)) {
    return value
  }

  return (x - mean) / sd
}

const STDEV = {};

STDEV.P = function () {
  const v = VAR.P.apply(this, arguments);
  let result = Math.sqrt(v);

  if (isNaN(result)) {
    result = num;
  }

  return result
};

STDEV.S = function () {
  const v = VAR.S.apply(this, arguments);
  const result = Math.sqrt(v);

  return result
};

function STDEVA() {
  const v = VARA.apply(this, arguments);
  const result = Math.sqrt(v);

  return result
}

function STDEVPA() {
  const v = VARPA.apply(this, arguments);
  let result = Math.sqrt(v);

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function STEYX(data_y, data_x) {
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));

  if (anyIsError(data_y, data_x)) {
    return value
  }

  const xmean = jStat__default["default"].mean(data_x);
  const ymean = jStat__default["default"].mean(data_y);
  const n = data_x.length;
  let lft = 0;
  let num = 0;
  let den = 0;

  for (let i = 0; i < n; i++) {
    lft += Math.pow(data_y[i] - ymean, 2);
    num += (data_x[i] - xmean) * (data_y[i] - ymean);
    den += Math.pow(data_x[i] - xmean, 2);
  }

  return Math.sqrt((lft - (num * num) / den) / (n - 2))
}

function TRANSPOSE(matrix) {
  if (!matrix) {
    return na
  }

  return jStat__default["default"].transpose(matrix)
}

const T = {};

T.DIST = (x, df, tails) => {
  if (tails !== 1 && tails !== 2) {
    return num
  }

  return tails === 1 ? T.DIST.RT(x, df) : T.DIST['2T'](x, df)
};

T.DIST['2T'] = function (x, df) {
  if (arguments.length !== 2) {
    return na
  }

  if (x < 0 || df < 1) {
    return num
  }

  if (typeof x !== 'number' || typeof df !== 'number') {
    return value
  }

  return (1 - jStat__default["default"].studentt.cdf(x, df)) * 2
};

T.DIST.RT = function (x, df) {
  if (arguments.length !== 2) {
    return na
  }

  if (x < 0 || df < 1) {
    return num
  }

  if (typeof x !== 'number' || typeof df !== 'number') {
    return value
  }

  return 1 - jStat__default["default"].studentt.cdf(x, df)
};

T.INV = (probability, df) => {
  probability = parseNumber(probability);
  df = parseNumber(df);

  if (anyIsError(probability, df)) {
    return value
  }

  return jStat__default["default"].studentt.inv(probability, df)
};

T.INV['2T'] = (probability, df) => {
  probability = parseNumber(probability);
  df = parseNumber(df);

  if (probability <= 0 || probability > 1 || df < 1) {
    return num
  }

  if (anyIsError(probability, df)) {
    return value
  }

  return Math.abs(jStat__default["default"].studentt.inv(probability / 2, df))
};

// The algorithm can be found here:
// http://www.chem.uoa.gr/applets/AppletTtest/Appl_Ttest2.html
T.TEST = (data_x, data_y) => {
  data_x = parseNumberArray(flatten(data_x));
  data_y = parseNumberArray(flatten(data_y));

  if (anyIsError(data_x, data_y)) {
    return value
  }

  const mean_x = jStat__default["default"].mean(data_x);
  const mean_y = jStat__default["default"].mean(data_y);
  let s_x = 0;
  let s_y = 0;
  let i;

  for (i = 0; i < data_x.length; i++) {
    s_x += Math.pow(data_x[i] - mean_x, 2);
  }

  for (i = 0; i < data_y.length; i++) {
    s_y += Math.pow(data_y[i] - mean_y, 2);
  }

  s_x = s_x / (data_x.length - 1);
  s_y = s_y / (data_y.length - 1);

  const t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x / data_x.length + s_y / data_y.length);

  return T.DIST['2T'](t, data_x.length + data_y.length - 2)
};

function TREND(data_y, data_x, new_data_x) {
  data_y = parseNumberArray(flatten(data_y));
  data_x = parseNumberArray(flatten(data_x));
  new_data_x = parseNumberArray(flatten(new_data_x));

  if (anyIsError(data_y, data_x, new_data_x)) {
    return value
  }

  const linest = LINEST(data_y, data_x);
  const m = linest[0];
  const b = linest[1];
  const result = [];

  new_data_x.forEach((x) => {
    result.push(m * x + b);
  });

  return result
}

function TRIMMEAN(range, percent) {
  range = parseNumberArray(flatten(range));
  percent = parseNumber(percent);

  if (anyIsError(range, percent)) {
    return value
  }

  const trim = FLOOR(range.length * percent, 2) / 2;

  return jStat__default["default"].mean(
    initial(
      rest(
        range.sort((a, b) => a - b),
        trim
      ),
      trim
    )
  )
}

const VAR = {};

VAR.P = function () {
  const range = numbers(flatten(arguments));
  const n = range.length;
  let sigma = 0;
  const mean = AVERAGE(range);
  let result;

  for (let i = 0; i < n; i++) {
    sigma += Math.pow(range[i] - mean, 2);
  }

  result = sigma / n;

  if (isNaN(result)) {
    result = num;
  }

  return result
};

VAR.S = function () {
  const range = numbers(flatten(arguments));
  const n = range.length;
  let sigma = 0;
  const mean = AVERAGE(range);

  for (let i = 0; i < n; i++) {
    sigma += Math.pow(range[i] - mean, 2);
  }

  return sigma / (n - 1)
};

function VARA() {
  const range = flatten(arguments);
  const n = range.length;
  let sigma = 0;
  let count = 0;
  const mean = AVERAGEA(range);

  for (let i = 0; i < n; i++) {
    const el = range[i];

    if (typeof el === 'number') {
      sigma += Math.pow(el - mean, 2);
    } else if (el === true) {
      sigma += Math.pow(1 - mean, 2);
    } else {
      sigma += Math.pow(0 - mean, 2);
    }

    if (el !== null) {
      count++;
    }
  }

  return sigma / (count - 1)
}

function VARPA() {
  const range = flatten(arguments);
  const n = range.length;
  let sigma = 0;
  let count = 0;
  const mean = AVERAGEA(range);
  let result;

  for (let i = 0; i < n; i++) {
    const el = range[i];

    if (typeof el === 'number') {
      sigma += Math.pow(el - mean, 2);
    } else if (el === true) {
      sigma += Math.pow(1 - mean, 2);
    } else {
      sigma += Math.pow(0 - mean, 2);
    }

    if (el !== null) {
      count++;
    }
  }

  result = sigma / count;

  if (isNaN(result)) {
    result = num;
  }

  return result
}

const WEIBULL = {};

WEIBULL.DIST = (x, alpha, beta, cumulative) => {
  x = parseNumber(x);
  alpha = parseNumber(alpha);
  beta = parseNumber(beta);

  if (anyIsError(x, alpha, beta)) {
    return value
  }

  return cumulative
    ? 1 - Math.exp(-Math.pow(x / beta, alpha))
    : (Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha) / Math.pow(beta, alpha)
};

const Z = {};

Z.TEST = (range, x, sd) => {
  range = parseNumberArray(flatten(range));
  x = parseNumber(x);

  if (anyIsError(range, x)) {
    return value
  }

  sd = sd || STDEV.S(range);
  const n = range.length;

  return 1 - NORM.S.DIST((AVERAGE(range) - x) / (sd / Math.sqrt(n)), true)
};

function ABS(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  const result = Math.abs(number);

  return result
}

function ACOS(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  let result = Math.acos(number);

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function ACOSH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  let result = Math.log(number + Math.sqrt(number * number - 1));

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function ACOT(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  const result = Math.atan(1 / number);

  return result
}

function ACOTH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  let result = 0.5 * Math.log((number + 1) / (number - 1));

  if (isNaN(result)) {
    result = num;
  }

  return result
}

// TODO: use options
function AGGREGATE(function_num, options, ref1, ref2) {
  function_num = parseNumber(function_num);
  options = parseNumber(function_num);

  if (anyIsError(function_num, options)) {
    return value
  }

  switch (function_num) {
    case 1:
      return AVERAGE(ref1)
    case 2:
      return COUNT(ref1)
    case 3:
      return COUNTA(ref1)
    case 4:
      return MAX(ref1)
    case 5:
      return MIN(ref1)
    case 6:
      return PRODUCT(ref1)
    case 7:
      return STDEV.S(ref1)
    case 8:
      return STDEV.P(ref1)
    case 9:
      return SUM(ref1)
    case 10:
      return VAR.S(ref1)
    case 11:
      return VAR.P(ref1)
    case 12:
      return MEDIAN(ref1)
    case 13:
      return MODE.SNGL(ref1)
    case 14:
      return LARGE(ref1, ref2)
    case 15:
      return SMALL(ref1, ref2)
    case 16:
      return PERCENTILE.INC(ref1, ref2)
    case 17:
      return QUARTILE.INC(ref1, ref2)
    case 18:
      return PERCENTILE.EXC(ref1, ref2)
    case 19:
      return QUARTILE.EXC(ref1, ref2)
  }
}

function ARABIC(text) {
  if (text === undefined || text === null) {
    return 0
  }

  if (text instanceof Error) {
    return text
  }

  // Credits: Rafa? Kukawski
  if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
    return value
  }

  let r = 0;
  text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, (i) => {
    r += {
      M: 1000,
      CM: 900,
      D: 500,
      CD: 400,
      C: 100,
      XC: 90,
      L: 50,
      XL: 40,
      X: 10,
      IX: 9,
      V: 5,
      IV: 4,
      I: 1
    }[i];
  });

  return r
}

function ASIN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  let result = Math.asin(number);

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function ASINH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.log(number + Math.sqrt(number * number + 1))
}

function ATAN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.atan(number)
}

function ATAN2(number_x, number_y) {
  number_x = parseNumber(number_x);
  number_y = parseNumber(number_y);
  const anyError$1 = anyError(number_x, number_y);

  if (anyError$1) {
    return anyError$1
  }

  return Math.atan2(number_x, number_y)
}

function ATANH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  let result = Math.log((1 + number) / (1 - number)) / 2;

  if (isNaN(result)) {
    result = num;
  }

  return result
}

function BASE(number, radix, min_length) {
  number = parseNumber(number);
  radix = parseNumber(radix);
  min_length = parseNumber(min_length);
  const anyError$1 = anyError(number, radix, min_length);

  if (anyError$1) {
    return anyError$1
  }

  if (radix === 0) {
    return num
  }

  const result = number.toString(radix);

  return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result
}

function CEILING(number, significance, mode) {
  number = parseNumber(number);
  significance = parseNumber(significance);
  mode = parseNumber(mode);
  const anyError$1 = anyError(number, significance, mode);

  if (anyError$1) {
    return anyError$1
  }

  if (significance === 0) {
    return 0
  }

  significance = Math.abs(significance);
  const precision = -Math.floor(Math.log(significance) / Math.log(10));

  if (number >= 0) {
    return ROUND(Math.ceil(number / significance) * significance, precision)
  } else {
    if (mode === 0) {
      return -ROUND(Math.floor(Math.abs(number) / significance) * significance, precision)
    } else {
      return -ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision)
    }
  }
}

CEILING.MATH = CEILING;

CEILING.PRECISE = CEILING;

function COMBIN(number, number_chosen) {
  number = parseNumber(number);
  number_chosen = parseNumber(number_chosen);
  const anyError$1 = anyError(number, number_chosen);

  if (anyError$1) {
    return anyError$1
  }

  if (number < number_chosen) {
    return num
  }

  return FACT(number) / (FACT(number_chosen) * FACT(number - number_chosen))
}

function COMBINA(number, number_chosen) {
  number = parseNumber(number);
  number_chosen = parseNumber(number_chosen);
  const anyError$1 = anyError(number, number_chosen);

  if (anyError$1) {
    return anyError$1
  }

  if (number < number_chosen) {
    return num
  }

  return number === 0 && number_chosen === 0 ? 1 : COMBIN(number + number_chosen - 1, number - 1)
}

function COS(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.cos(number)
}

function COSH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return (Math.exp(number) + Math.exp(-number)) / 2
}

function COT(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return div0
  }

  return 1 / Math.tan(number)
}

function COTH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return div0
  }

  const e2 = Math.exp(2 * number);

  return (e2 + 1) / (e2 - 1)
}

function CSC(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return div0
  }

  return 1 / Math.sin(number)
}

function CSCH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return div0
  }

  return 2 / (Math.exp(number) - Math.exp(-number))
}

function DECIMAL(number, radix) {
  if (arguments.length < 1) {
    return value
  }

  number = parseNumber(number);
  radix = parseNumber(radix);
  const anyError$1 = anyError(number, radix);

  if (anyError$1) {
    return anyError$1
  }

  if (radix === 0) {
    return num
  }

  return parseInt(number, radix)
}

function DEGREES(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return (number * 180) / Math.PI
}

function EVEN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return CEILING(number, -2, -1)
}

function EXP(number) {
  if (arguments.length < 1) {
    return na
  }

  if (arguments.length > 1) {
    return error
  }

  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  number = Math.exp(number);

  return number
}

const MEMOIZED_FACT = [];
function FACT(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  const n = Math.floor(number);

  if (n === 0 || n === 1) {
    return 1
  } else if (MEMOIZED_FACT[n] > 0) {
    return MEMOIZED_FACT[n]
  } else {
    MEMOIZED_FACT[n] = FACT(n - 1) * n;

    return MEMOIZED_FACT[n]
  }
}

function FACTDOUBLE(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  const n = Math.floor(number);

  if (n <= 0) {
    return 1
  } else {
    return n * FACTDOUBLE(n - 2)
  }
}

function FLOOR(number, significance) {
  number = parseNumber(number);
  significance = parseNumber(significance);
  const anyError$1 = anyError(number, significance);

  if (anyError$1) {
    return anyError$1
  }

  if (significance === 0) {
    return 0
  }

  if (!(number >= 0 && significance > 0) && !(number <= 0 && significance < 0)) {
    return num
  }

  significance = Math.abs(significance);
  const precision = -Math.floor(Math.log(significance) / Math.log(10));

  if (number >= 0) {
    return ROUND(Math.floor(number / significance) * significance, precision)
  } else {
    return -ROUND(Math.ceil(Math.abs(number) / significance), precision)
  }
}

// TODO: Verify
FLOOR.MATH = (number, significance, mode) => {
  if (significance instanceof Error) {
    return significance
  }

  significance = significance === undefined ? 0 : significance;

  number = parseNumber(number);
  significance = parseNumber(significance);
  mode = parseNumber(mode);
  const anyError$1 = anyError(number, significance, mode);

  if (anyError$1) {
    return anyError$1
  }

  if (significance === 0) {
    return 0
  }

  significance = significance ? Math.abs(significance) : 1;
  const precision = -Math.floor(Math.log(significance) / Math.log(10));

  if (number >= 0) {
    return ROUND(Math.floor(number / significance) * significance, precision)
  } else if (mode === 0 || mode === undefined) {
    return -ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision)
  }

  return -ROUND(Math.floor(Math.abs(number) / significance) * significance, precision)
};

// Deprecated
FLOOR.PRECISE = FLOOR.MATH;

// adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
function GCD() {
  const range = parseNumberArray(flatten(arguments));

  if (range instanceof Error) {
    return range
  }

  const n = range.length;
  const r0 = range[0];
  let x = r0 < 0 ? -r0 : r0;

  for (let i = 1; i < n; i++) {
    const ri = range[i];
    let y = ri < 0 ? -ri : ri;

    while (x && y) {
      if (x > y) {
        x %= y;
      } else {
        y %= x;
      }
    }

    x += y;
  }

  return x
}

function INT(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.floor(number)
}

// TODO: verify
const ISO = {
  CEILING: CEILING
};

function LCM() {
  // Credits: Jonas Raoni Soares Silva
  const o = parseNumberArray(flatten(arguments));

  if (o instanceof Error) {
    return o
  }

  for (var i, j, n, d, r = 1; (n = o.pop()) !== undefined; ) {
    if (n === 0) {
      return 0
    }

    while (n > 1) {
      if (n % 2) {
        for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
          // empty
        }

        d = i <= j ? i : n;
      } else {
        d = 2;
      }

      for (n /= d, r *= d, i = o.length; i; o[--i] % d === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
        // empty
      }
    }
  }

  return r
}

function LN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return num
  }

  return Math.log(number)
}

function LN10() {
  return Math.log(10)
}

function LN2() {
  return Math.log(2)
}

function LOG10E() {
  return Math.LOG10E
}

function LOG2E() {
  return Math.LOG2E
}

function LOG(number, base) {
  number = parseNumber(number);
  base = parseNumber(base);
  const anyError$1 = anyError(number, base);

  if (anyError$1) {
    return anyError$1
  }

  if (number === 0 || base === 0) {
    return num
  }

  return Math.log(number) / Math.log(base)
}

function LOG10(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number === 0) {
    return num
  }

  return Math.log(number) / Math.log(10)
}

function MOD(dividend, divisor) {
  dividend = parseNumber(dividend);
  divisor = parseNumber(divisor);
  const anyError$1 = anyError(dividend, divisor);

  if (anyError$1) {
    return anyError$1
  }

  if (divisor === 0) {
    return div0
  }

  let modulus = Math.abs(dividend % divisor);
  modulus = dividend < 0 ? divisor - modulus : modulus;

  return divisor > 0 ? modulus : -modulus
}

function MROUND(number, multiple) {
  number = parseNumber(number);
  multiple = parseNumber(multiple);
  const anyError$1 = anyError(number, multiple);

  if (anyError$1) {
    return anyError$1
  }

  if (number * multiple === 0) {
    return 0
  }

  if (number * multiple < 0) {
    return num
  }

  return Math.round(number / multiple) * multiple
}

function MULTINOMIAL() {
  const args = parseNumberArray(flatten(arguments));

  if (args instanceof Error) {
    return args
  }

  let sum = 0;
  let divisor = 1;

  for (let i = 0; i < args.length; i++) {
    sum += args[i];
    divisor *= FACT(args[i]);
  }

  return FACT(sum) / divisor
}

function ODD(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  let temp = Math.ceil(Math.abs(number));
  temp = temp & 1 ? temp : temp + 1;

  return number >= 0 ? temp : -temp
}

function PI() {
  return Math.PI
}

function E() {
  return Math.E
}

function POWER(number, power) {
  number = parseNumber(number);
  power = parseNumber(power);
  const anyError$1 = anyError(number, power);

  if (anyError$1) {
    return anyError$1
  }

  if (number === 0 && power === 0) {
    return num
  }

  const result = Math.pow(number, power);

  if (isNaN(result)) {
    return num
  }

  return result
}

function PRODUCT() {
  const flatArguments = flatten(arguments);
  const flatArgumentsDefined = flatArguments.filter((arg) => arg !== undefined && arg !== null);

  if (flatArgumentsDefined.length === 0) {
    return 0
  }

  const args = parseNumberArray(flatArgumentsDefined);

  if (args instanceof Error) {
    return args
  }

  let result = 1;

  for (let i = 0; i < args.length; i++) {
    result *= args[i];
  }

  return result
}

function QUOTIENT(numerator, denominator) {
  numerator = parseNumber(numerator);
  denominator = parseNumber(denominator);
  const anyError$1 = anyError(numerator, denominator);

  if (anyError$1) {
    return anyError$1
  }

  return parseInt(numerator / denominator, 10)
}

function RADIANS(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return (number * Math.PI) / 180
}

function RAND() {
  return Math.random()
}

function RANDBETWEEN(bottom, top) {
  bottom = parseNumber(bottom);
  top = parseNumber(top);
  const anyError$1 = anyError(bottom, top);

  if (anyError$1) {
    return anyError$1
  }
  // Creative Commons Attribution 3.0 License
  // Copyright (c) 2012 eqcode

  return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1
}

// TODO
function ROMAN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  // The MIT License
  // Copyright (c) 2008 Steven Levithan
  const digits = String(number).split('');
  const key = [
    '',
    'C',
    'CC',
    'CCC',
    'CD',
    'D',
    'DC',
    'DCC',
    'DCCC',
    'CM',
    '',
    'X',
    'XX',
    'XXX',
    'XL',
    'L',
    'LX',
    'LXX',
    'LXXX',
    'XC',
    '',
    'I',
    'II',
    'III',
    'IV',
    'V',
    'VI',
    'VII',
    'VIII',
    'IX'
  ];
  let roman = '';
  let i = 3;

  while (i--) {
    roman = (key[+digits.pop() + i * 10] || '') + roman;
  }

  return new Array(+digits.join('') + 1).join('M') + roman
}

function ROUND(number, digits) {
  number = parseNumber(number);
  digits = parseNumber(digits);
  const anyError$1 = anyError(number, digits);

  if (anyError$1) {
    return anyError$1
  }

  return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits)
}

function ROUNDDOWN(number, digits) {
  number = parseNumber(number);
  digits = parseNumber(digits);
  const anyError$1 = anyError(number, digits);

  if (anyError$1) {
    return anyError$1
  }

  const sign = number > 0 ? 1 : -1;

  return (sign * Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits)
}

function ROUNDUP(number, digits) {
  number = parseNumber(number);
  digits = parseNumber(digits);
  const anyError$1 = anyError(number, digits);

  if (anyError$1) {
    return anyError$1
  }

  const sign = number > 0 ? 1 : -1;

  return (sign * Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits)
}

function SEC(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return 1 / Math.cos(number)
}

function SECH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return 2 / (Math.exp(number) + Math.exp(-number))
}

function SERIESSUM(x, n, m, coefficients) {
  x = parseNumber(x);
  n = parseNumber(n);
  m = parseNumber(m);
  coefficients = parseNumberArray(coefficients);

  if (anyIsError(x, n, m, coefficients)) {
    return value
  }

  let result = coefficients[0] * Math.pow(x, n);

  for (let i = 1; i < coefficients.length; i++) {
    result += coefficients[i] * Math.pow(x, n + i * m);
  }

  return result
}

function SIGN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number < 0) {
    return -1
  } else if (number === 0) {
    return 0
  } else {
    return 1
  }
}

function SIN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.sin(number)
}

function SINH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return (Math.exp(number) - Math.exp(-number)) / 2
}

function SQRT(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  if (number < 0) {
    return num
  }

  return Math.sqrt(number)
}

function SQRTPI(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.sqrt(number * Math.PI)
}

function SQRT1_2() {
  return 1 / Math.sqrt(2)
}

function SQRT2() {
  return Math.sqrt(2)
}

function SUBTOTAL(function_code, ref1) {
  function_code = parseNumber(function_code);

  if (function_code instanceof Error) {
    return function_code
  }

  switch (function_code) {
    case 1:
      return AVERAGE(ref1)
    case 2:
      return COUNT(ref1)
    case 3:
      return COUNTA(ref1)
    case 4:
      return MAX(ref1)
    case 5:
      return MIN(ref1)
    case 6:
      return PRODUCT(ref1)
    case 7:
      return STDEV.S(ref1)
    case 8:
      return STDEV.P(ref1)
    case 9:
      return SUM(ref1)
    case 10:
      return VAR.S(ref1)
    case 11:
      return VAR.P(ref1)
    // no hidden values for us
    case 101:
      return AVERAGE(ref1)
    case 102:
      return COUNT(ref1)
    case 103:
      return COUNTA(ref1)
    case 104:
      return MAX(ref1)
    case 105:
      return MIN(ref1)
    case 106:
      return PRODUCT(ref1)
    case 107:
      return STDEV.S(ref1)
    case 108:
      return STDEV.P(ref1)
    case 109:
      return SUM(ref1)
    case 110:
      return VAR.S(ref1)
    case 111:
      return VAR.P(ref1)
  }
}

function ADD(num1, num2) {
  if (arguments.length !== 2) {
    return na
  }

  num1 = parseNumber(num1);
  num2 = parseNumber(num2);
  const anyError$1 = anyError(num1, num2);

  if (anyError$1) {
    return anyError$1
  }

  return num1 + num2
}

function MINUS(num1, num2) {
  if (arguments.length !== 2) {
    return na
  }

  num1 = parseNumber(num1);
  num2 = parseNumber(num2);
  const anyError$1 = anyError(num1, num2);

  if (anyError$1) {
    return anyError$1
  }

  return num1 - num2
}

function DIVIDE(dividend, divisor) {
  if (arguments.length !== 2) {
    return na
  }

  dividend = parseNumber(dividend);
  divisor = parseNumber(divisor);
  const anyError$1 = anyError(dividend, divisor);

  if (anyError$1) {
    return anyError$1
  }

  if (divisor === 0) {
    return div0
  }

  return dividend / divisor
}

function MULTIPLY(factor1, factor2) {
  if (arguments.length !== 2) {
    return na
  }

  factor1 = parseNumber(factor1);
  factor2 = parseNumber(factor2);
  const anyError$1 = anyError(factor1, factor2);

  if (anyError$1) {
    return anyError$1
  }

  return factor1 * factor2
}

function GT(num1, num2) {
  if (arguments.length !== 2) {
    return na
  }

  if (num1 instanceof Error) {
    return num1
  }

  if (num2 instanceof Error) {
    return num2
  }

  if (anyIsString(num1, num2)) {
    num1 = parseString(num1);
    num2 = parseString(num2);
  } else {
    num1 = parseNumber(num1);
    num2 = parseNumber(num2);
  }

  const anyError$1 = anyError(num1, num2);

  if (anyError$1) {
    return anyError$1
  }

  return num1 > num2
}

function GTE(num1, num2) {
  if (arguments.length !== 2) {
    return na
  }

  if (anyIsString(num1, num2)) {
    num1 = parseString(num1);
    num2 = parseString(num2);
  } else {
    num1 = parseNumber(num1);
    num2 = parseNumber(num2);
  }

  const anyError$1 = anyError(num1, num2);

  if (anyError$1) {
    return anyError$1
  }

  return num1 >= num2
}

function LT(num1, num2) {
  if (arguments.length !== 2) {
    return na
  }

  if (anyIsString(num1, num2)) {
    num1 = parseString(num1);
    num2 = parseString(num2);
  } else {
    num1 = parseNumber(num1);
    num2 = parseNumber(num2);
  }

  const anyError$1 = anyError(num1, num2);

  if (anyError$1) {
    return anyError$1
  }

  return num1 < num2
}

function LTE(num1, num2) {
  if (arguments.length !== 2) {
    return na
  }

  if (anyIsString(num1, num2)) {
    num1 = parseString(num1);
    num2 = parseString(num2);
  } else {
    num1 = parseNumber(num1);
    num2 = parseNumber(num2);
  }

  const anyError$1 = anyError(num1, num2);

  if (anyError$1) {
    return anyError$1
  }

  return num1 <= num2
}

function EQ(value1, value2) {
  if (arguments.length !== 2) {
    return na
  }

  if (value1 instanceof Error) {
    return value1
  }

  if (value2 instanceof Error) {
    return value2
  }

  if (value1 === null) {
    value1 = undefined;
  }

  if (value2 === null) {
    value2 = undefined;
  }

  return value1 === value2
}

function NE(value1, value2) {
  if (arguments.length !== 2) {
    return na
  }

  if (value1 instanceof Error) {
    return value1
  }

  if (value2 instanceof Error) {
    return value2
  }

  if (value1 === null) {
    value1 = undefined;
  }

  if (value2 === null) {
    value2 = undefined;
  }

  return value1 !== value2
}

function POW(base, exponent) {
  if (arguments.length !== 2) {
    return na
  }

  return POWER(base, exponent)
}

function SUM() {
  let result = 0;

  arrayEach(argsToArray(arguments), (value) => {
    if (result instanceof Error) {
      return false
    } else if (value instanceof Error) {
      result = value;
    } else if (typeof value === 'number') {
      result += value;
    } else if (typeof value === 'string') {
      const parsed = parseFloat(value);

      !isNaN(parsed) && (result += parsed);
    } else if (Array.isArray(value)) {
      const inner_result = SUM.apply(null, value);

      if (inner_result instanceof Error) {
        result = inner_result;
      } else {
        result += inner_result;
      }
    }
  });

  return result
}

function SUMIF(range, criteria, sumRange) {
  range = flatten(range);

  if (sumRange) {
    sumRange = flatten(sumRange);
  } else {
    sumRange = range;
  }

  if (range instanceof Error) {
    return range
  }

  if (criteria === undefined || criteria === null || criteria instanceof Error) {
    return 0
  }

  let result = 0;
  const isWildcard = criteria === '*';
  const tokenizedCriteria = isWildcard ? null : parse(criteria + '');

  for (let i = 0; i < range.length; i++) {
    const value = range[i];
    const sumValue = sumRange[i];

    if (isWildcard) {
      result += value;
    } else {
      const tokens = [createToken(value, TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);

      result += compute(tokens) ? sumValue : 0;
    }
  }

  return result
}

function SUMIFS() {
  const args = argsToArray(arguments);
  const range = parseNumberArray(flatten(args.shift()));

  if (range instanceof Error) {
    return range
  }

  const criterias = args;
  const criteriaLength = criterias.length / 2;

  for (let i = 0; i < criteriaLength; i++) {
    criterias[i * 2] = flatten(criterias[i * 2]);
  }

  let result = 0;

  for (let i = 0; i < range.length; i++) {
    let isMeetCondition = false;

    for (let j = 0; j < criteriaLength; j++) {
      const valueToTest = criterias[j * 2][i];
      const criteria = criterias[j * 2 + 1];
      const isWildcard = criteria === void 0 || criteria === '*';
      let computedResult = false;

      if (isWildcard) {
        computedResult = true;
      } else {
        const tokenizedCriteria = parse(criteria + '');
        const tokens = [createToken(valueToTest, TOKEN_TYPE_LITERAL)].concat(
          tokenizedCriteria
        );

        computedResult = compute(tokens);
      }

      // Criterias are calculated as AND so any `false` breakes the loop as unmeet condition
      if (!computedResult) {
        isMeetCondition = false;
        break
      }

      isMeetCondition = true;
    }

    if (isMeetCondition) {
      result += range[i];
    }
  }

  return result
}

function SUMPRODUCT() {
  if (!arguments || arguments.length === 0) {
    return value
  }

  const arrays = arguments.length + 1;
  let result = 0;
  let product;
  let k;
  let _i;
  let _ij;

  for (let i = 0; i < arguments[0].length; i++) {
    if (!(arguments[0][i] instanceof Array)) {
      product = 1;

      for (k = 1; k < arrays; k++) {
        const _i_arg = arguments[k - 1][i];

        if (_i_arg instanceof Error) {
          return _i_arg
        }

        _i = parseNumber(_i_arg);

        if (_i instanceof Error) {
          return _i
        }

        product *= _i;
      }

      result += product;
    } else {
      for (let j = 0; j < arguments[0][i].length; j++) {
        product = 1;

        for (k = 1; k < arrays; k++) {
          const _ij_arg = arguments[k - 1][i][j];

          if (_ij_arg instanceof Error) {
            return _ij_arg
          }

          _ij = parseNumber(_ij_arg);

          if (_ij instanceof Error) {
            return _ij
          }

          product *= _ij;
        }

        result += product;
      }
    }
  }

  return result
}

function SUMSQ() {
  const numbers = parseNumberArray(flatten(arguments));

  if (numbers instanceof Error) {
    return numbers
  }

  let result = 0;
  const length = numbers.length;

  for (let i = 0; i < length; i++) {
    result += ISNUMBER(numbers[i]) ? numbers[i] * numbers[i] : 0;
  }

  return result
}

function SUMX2MY2(array_x, array_y) {
  array_x = parseNumberArray(flatten(array_x));
  array_y = parseNumberArray(flatten(array_y));

  if (anyIsError(array_x, array_y)) {
    return value
  }

  let result = 0;

  for (let i = 0; i < array_x.length; i++) {
    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
  }

  return result
}

function SUMX2PY2(array_x, array_y) {
  array_x = parseNumberArray(flatten(array_x));
  array_y = parseNumberArray(flatten(array_y));

  if (anyIsError(array_x, array_y)) {
    return value
  }

  let result = 0;
  array_x = parseNumberArray(flatten(array_x));
  array_y = parseNumberArray(flatten(array_y));

  for (let i = 0; i < array_x.length; i++) {
    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
  }

  return result
}

function SUMXMY2(array_x, array_y) {
  array_x = parseNumberArray(flatten(array_x));
  array_y = parseNumberArray(flatten(array_y));

  if (anyIsError(array_x, array_y)) {
    return value
  }

  let result = 0;
  array_x = flatten(array_x);
  array_y = flatten(array_y);

  for (let i = 0; i < array_x.length; i++) {
    result += Math.pow(array_x[i] - array_y[i], 2);
  }

  return result
}

function TAN(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  return Math.tan(number)
}

function TANH(number) {
  number = parseNumber(number);

  if (number instanceof Error) {
    return number
  }

  const e2 = Math.exp(2 * number);

  return (e2 - 1) / (e2 + 1)
}

function TRUNC(number, digits) {
  number = parseNumber(number);
  digits = parseNumber(digits);
  const anyError$1 = anyError(number, digits);

  if (anyError$1) {
    return anyError$1
  }

  const sign = number > 0 ? 1 : -1;

  return (sign * Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits)
}

const BETADIST = BETA.DIST;
const BETAINV = BETA.INV;
const BINOMDIST = BINOM.DIST;
const CEILINGMATH = CEILING.MATH;
const CEILINGPRECISE = CEILING.PRECISE;
const CHIDIST = CHISQ.DIST;
const CHIDISTRT = CHISQ.DIST.RT;
const CHIINV = CHISQ.INV;
const CHIINVRT = CHISQ.INV.RT;
const CHITEST = CHISQ.TEST;
const COVAR = COVARIANCE.P;
const COVARIANCEP = COVARIANCE.P;
const COVARIANCES = COVARIANCE.S;
const CRITBINOM = BINOM.INV;
const ERFCPRECISE = ERFC.PRECISE;
const ERFPRECISE = ERF.PRECISE;
const EXPONDIST = EXPON.DIST;
const FDIST = F.DIST;
const FDISTRT = F.DIST.RT;
const FINV = F.INV;
const FINVRT = F.INV.RT;
const FLOORMATH = FLOOR.MATH;
const FLOORPRECISE = FLOOR.PRECISE;
const FTEST = F.TEST;
const GAMMADIST = GAMMA.DIST;
const GAMMAINV = GAMMA.INV;
const GAMMALNPRECISE = GAMMALN.PRECISE;
const HYPGEOMDIST = HYPGEOM.DIST;
const LOGINV = LOGNORM.INV;
const LOGNORMDIST = LOGNORM.DIST;
const LOGNORMINV = LOGNORM.INV;
const MODEMULT = MODE.MULT;
const MODESNGL = MODE.SNGL;
const NEGBINOMDIST = NEGBINOM.DIST;
const NETWORKDAYSINTL = NETWORKDAYS.INTL;
const NORMDIST = NORM.DIST;
const NORMINV = NORM.INV;
const NORMSDIST = NORM.S.DIST;
const NORMSINV = NORM.S.INV;
const PERCENTILEEXC = PERCENTILE.EXC;
const PERCENTILEINC = PERCENTILE.INC;
const PERCENTRANKEXC = PERCENTRANK.EXC;
const PERCENTRANKINC = PERCENTRANK.INC;
const POISSONDIST = POISSON.DIST;
const QUARTILEEXC = QUARTILE.EXC;
const QUARTILEINC = QUARTILE.INC;
const RANKAVG = RANK.AVG;
const RANKEQ = RANK.EQ;
const SKEWP = SKEW.P;
const STDEVP = STDEV.P;
const STDEVS = STDEV.S;
const TDIST = T.DIST;
const TDISTRT = T.DIST.RT;
const TINV = T.INV;
const TTEST = T.TEST;
const VARP = VAR.P;
const VARS = VAR.S;
const WEIBULLDIST = WEIBULL.DIST;
const WORKDAYINTL = WORKDAY.INTL;
const ZTEST = Z.TEST;

function compact(array) {
  const result = [];

  arrayEach(array, (value) => {
    if (value) {
      result.push(value);
    }
  });

  return result
}

function FINDFIELD(database, title) {
  let index = null;

  arrayEach(database, (value, i) => {
    if (value[0] === title) {
      index = i;

      return false
    }
  });

  // Return error if the input field title is incorrect
  if (index == null) {
    return value
  }

  return index
}

function findResultIndex(database, criterias) {
  const matches = {};

  for (let i = 1; i < database[0].length; ++i) {
    matches[i] = true;
  }

  let maxCriteriaLength = criterias[0].length;

  for (let i = 1; i < criterias.length; ++i) {
    if (criterias[i].length > maxCriteriaLength) {
      maxCriteriaLength = criterias[i].length;
    }
  }

  for (let k = 1; k < database.length; ++k) {
    for (let l = 1; l < database[k].length; ++l) {
      let currentCriteriaResult = false;
      let hasMatchingCriteria = false;

      for (let j = 0; j < criterias.length; ++j) {
        const criteria = criterias[j];

        if (criteria.length < maxCriteriaLength) {
          continue
        }

        const criteriaField = criteria[0];

        if (database[k][0] !== criteriaField) {
          continue
        }

        hasMatchingCriteria = true;

        for (let p = 1; p < criteria.length; ++p) {
          if (!currentCriteriaResult) {
            const isWildcard = criteria[p] === void 0 || criteria[p] === '*';

            if (isWildcard) {
              currentCriteriaResult = true;
            } else {
              const tokenizedCriteria = parse(criteria[p] + '');
              const tokens = [createToken(database[k][l], TOKEN_TYPE_LITERAL)].concat(
                tokenizedCriteria
              );

              currentCriteriaResult = compute(tokens);
            }
          }
        }
      }

      if (hasMatchingCriteria) {
        matches[l] = matches[l] && currentCriteriaResult;
      }
    }
  }

  const result = [];

  for (let n = 0; n < database[0].length; ++n) {
    if (matches[n]) {
      result.push(n - 1);
    }
  }

  return result
}

// Database functions
function DAVERAGE(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  let sum = 0;

  arrayEach(resultIndexes, (value) => {
    sum += targetFields[value];
  });

  return resultIndexes.length === 0 ? div0 : sum / resultIndexes.length
}

function DCOUNT(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  const targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  return COUNT(targetValues)
}

function DCOUNTA(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  const targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  return COUNTA(targetValues)
}

function DGET(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  // Return error if no record meets the criteria
  if (resultIndexes.length === 0) {
    return value
  }
  // Returns the #NUM! error value because more than one record meets the
  // criteria
  if (resultIndexes.length > 1) {
    return num
  }

  return targetFields[resultIndexes[0]]
}

function DMAX(database, field, criteria) {
  // Return error if field is not a number and not a string

  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  let maxValue = targetFields[resultIndexes[0]];

  arrayEach(resultIndexes, (value) => {
    if (maxValue < targetFields[value]) {
      maxValue = targetFields[value];
    }
  });

  return maxValue
}

function DMIN(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  let minValue = targetFields[resultIndexes[0]];

  arrayEach(resultIndexes, (value) => {
    if (minValue > targetFields[value]) {
      minValue = targetFields[value];
    }
  });

  return minValue
}

function DPRODUCT(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  let targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });
  targetValues = compact(targetValues);

  let result = 1;

  arrayEach(targetValues, (value) => {
    result *= value;
  });

  return result
}

function DSTDEV(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  let targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  targetValues = compact(targetValues);

  return STDEV.S(targetValues)
}

function DSTDEVP(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  let targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  targetValues = compact(targetValues);

  return STDEV.P(targetValues)
}

function DSUM(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  const targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  return SUM(targetValues)
}

function DVAR(database, field, criteria) {
  // Return error if field is not a number and not a string
  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  const targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  return VAR.S(targetValues)
}

function DVARP(database, field, criteria) {
  // Return error if field is not a number and not a string

  if (isNaN(field) && typeof field !== 'string') {
    return value
  }

  const resultIndexes = findResultIndex(database, criteria);
  let targetFields = [];

  if (typeof field === 'string') {
    const index = FINDFIELD(database, field);
    targetFields = rest(database[index]);
  } else {
    targetFields = rest(database[field]);
  }

  const targetValues = [];

  arrayEach(resultIndexes, (value) => {
    targetValues.push(targetFields[value]);
  });

  return VAR.P(targetValues)
}

function validDate(d) {
  return d && d.getTime && !isNaN(d.getTime())
}

function ensureDate(d) {
  return d instanceof Date ? d : new Date(d)
}

function ACCRINT(issue, first, settlement, rate, par, frequency, basis) {
  // Return error if either date is invalid
  issue = ensureDate(issue);
  first = ensureDate(first);
  settlement = ensureDate(settlement);

  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
    return value
  }

  // Return error if either rate or par are lower than or equal to zero
  if (rate <= 0 || par <= 0) {
    return num
  }

  // Return error if frequency is neither 1, 2, or 4
  if ([1, 2, 4].indexOf(frequency) === -1) {
    return num
  }

  // Return error if basis is neither 0, 1, 2, 3, or 4
  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
    return num
  }

  // Return error if settlement is before or equal to issue
  if (settlement <= issue) {
    return num
  }

  // Set default values
  par = par || 0;
  basis = basis || 0;

  // Compute accrued interest

  return par * rate * YEARFRAC(issue, settlement, basis)
}

// TODO
function ACCRINTM() {
  throw new Error('ACCRINTM is not implemented')
}

// TODO
function AMORDEGRC() {
  throw new Error('AMORDEGRC is not implemented')
}

// TODO
function AMORLINC() {
  throw new Error('AMORLINC is not implemented')
}

// TODO
function COUPDAYBS() {
  throw new Error('COUPDAYBS is not implemented')
}

// TODO
function COUPDAYS() {
  throw new Error('COUPDAYS is not implemented')
}

// TODO
function COUPDAYSNC() {
  throw new Error('COUPDAYSNC is not implemented')
}

// TODO
function COUPNCD() {
  throw new Error('COUPNCD is not implemented')
}

// TODO
function COUPNUM() {
  throw new Error('COUPNUM is not implemented')
}

// TODO
function COUPPCD() {
  throw new Error('COUPPCD is not implemented')
}

function CUMIPMT(rate, periods, value$1, start, end, type) {
  rate = parseNumber(rate);
  periods = parseNumber(periods);
  value$1 = parseNumber(value$1);

  if (anyIsError(rate, periods, value$1)) {
    return value
  }

  if (rate <= 0 || periods <= 0 || value$1 <= 0) {
    return num
  }

  if (start < 1 || end < 1 || start > end) {
    return num
  }

  if (type !== 0 && type !== 1) {
    return num
  }

  const payment = PMT(rate, periods, value$1, 0, type);
  let interest = 0;

  if (start === 1) {
    if (type === 0) {
      interest = -value$1;
    }

    start++;
  }

  for (let i = start; i <= end; i++) {
    if (type === 1) {
      interest += FV(rate, i - 2, payment, value$1, 1) - payment;
    } else {
      interest += FV(rate, i - 1, payment, value$1, 0);
    }
  }

  interest *= rate;

  return interest
}

function CUMPRINC(rate, periods, value$1, start, end, type) {
  // Credits: algorithm inspired by Apache OpenOffice
  // Credits: Hannes Stiebitzhofer for the translations of function and variable names
  rate = parseNumber(rate);
  periods = parseNumber(periods);
  value$1 = parseNumber(value$1);

  if (anyIsError(rate, periods, value$1)) {
    return value
  }

  // Return error if either rate, periods, or value are lower than or equal to zero
  if (rate <= 0 || periods <= 0 || value$1 <= 0) {
    return num
  }

  // Return error if start < 1, end < 1, or start > end
  if (start < 1 || end < 1 || start > end) {
    return num
  }

  // Return error if type is neither 0 nor 1
  if (type !== 0 && type !== 1) {
    return num
  }

  // Compute cumulative principal
  const payment = PMT(rate, periods, value$1, 0, type);
  let principal = 0;

  if (start === 1) {
    if (type === 0) {
      principal = payment + value$1 * rate;
    } else {
      principal = payment;
    }

    start++;
  }

  for (let i = start; i <= end; i++) {
    if (type > 0) {
      principal += payment - (FV(rate, i - 2, payment, value$1, 1) - payment) * rate;
    } else {
      principal += payment - FV(rate, i - 1, payment, value$1, 0) * rate;
    }
  }

  // Return cumulative principal

  return principal
}

function DB(cost, salvage, life, period, month) {
  // Initialize month
  month = month === undefined ? 12 : month;

  cost = parseNumber(cost);
  salvage = parseNumber(salvage);
  life = parseNumber(life);
  period = parseNumber(period);
  month = parseNumber(month);

  if (anyIsError(cost, salvage, life, period, month)) {
    return value
  }

  // Return error if any of the parameters is negative
  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
    return num
  }

  // Return error if month is not an integer between 1 and 12
  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
    return num
  }

  // Return error if period is greater than life
  if (period > life) {
    return num
  }

  // Return 0 (zero) if salvage is greater than or equal to cost
  if (salvage >= cost) {
    return 0
  }

  // Rate is rounded to three decimals places
  const rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);

  // Compute initial depreciation
  const initial = (cost * rate * month) / 12;

  // Compute total depreciation
  let total = initial;
  let current = 0;
  const ceiling = period === life ? life - 1 : period;

  for (let i = 2; i <= ceiling; i++) {
    current = (cost - total) * rate;
    total += current;
  }

  // Depreciation for the first and last periods are special cases
  if (period === 1) {
    // First period
    return initial
  } else if (period === life) {
    // Last period

    return (cost - total) * rate
  } else {
    return current
  }
}

function DDB(cost, salvage, life, period, factor) {
  // Initialize factor
  factor = factor === undefined ? 2 : factor;

  cost = parseNumber(cost);
  salvage = parseNumber(salvage);
  life = parseNumber(life);
  period = parseNumber(period);
  factor = parseNumber(factor);

  if (anyIsError(cost, salvage, life, period, factor)) {
    return value
  }

  // Return error if any of the parameters is negative or if factor is null
  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
    return num
  }

  // Return error if period is greater than life
  if (period > life) {
    return num
  }

  // Return 0 (zero) if salvage is greater than or equal to cost
  if (salvage >= cost) {
    return 0
  }

  // Compute depreciation
  let total = 0;
  let current = 0;

  for (let i = 1; i <= period; i++) {
    current = Math.min((cost - total) * (factor / life), cost - salvage - total);
    total += current;
  }

  // Return depreciation
  return current
}

// TODO
function DISC() {
  throw new Error('DISC is not implemented')
}

function DOLLARDE(dollar, fraction) {
  // Credits: algorithm inspired by Apache OpenOffice
  dollar = parseNumber(dollar);
  fraction = parseNumber(fraction);

  if (anyIsError(dollar, fraction)) {
    return value
  }

  // Return error if fraction is negative
  if (fraction < 0) {
    return num
  }

  // Return error if fraction is greater than or equal to 0 and less than 1
  if (fraction >= 0 && fraction < 1) {
    return div0
  }

  // Truncate fraction if it is not an integer
  fraction = parseInt(fraction, 10);

  // Compute integer part
  let result = parseInt(dollar, 10);

  // Add decimal part
  result += ((dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10))) / fraction;

  // Round result
  const power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
  result = Math.round(result * power) / power;

  // Return converted dollar price
  return result
}

function DOLLARFR(dollar, fraction) {
  // Credits: algorithm inspired by Apache OpenOffice
  dollar = parseNumber(dollar);
  fraction = parseNumber(fraction);

  if (anyIsError(dollar, fraction)) {
    return value
  }

  // Return error if fraction is negative
  if (fraction < 0) {
    return num
  }

  // Return error if fraction is greater than or equal to 0 and less than 1
  if (fraction >= 0 && fraction < 1) {
    return div0
  }

  // Truncate fraction if it is not an integer
  fraction = parseInt(fraction, 10);

  // Compute integer part
  let result = parseInt(dollar, 10);

  // Add decimal part
  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;

  // Return converted dollar price
  return result
}

// TODO
function DURATION() {
  throw new Error('DURATION is not implemented')
}

function EFFECT(rate, periods) {
  rate = parseNumber(rate);
  periods = parseNumber(periods);

  if (anyIsError(rate, periods)) {
    return value
  }

  // Return error if rate <=0 or periods < 1
  if (rate <= 0 || periods < 1) {
    return num
  }

  // Truncate periods if it is not an integer
  periods = parseInt(periods, 10);

  // Return effective annual interest rate
  return Math.pow(1 + rate / periods, periods) - 1
}

function FV(rate, periods, payment, value$1, type) {
  // Credits: algorithm inspired by Apache OpenOffice
  value$1 = value$1 || 0;
  type = type || 0;

  rate = parseNumber(rate);
  periods = parseNumber(periods);
  payment = parseNumber(payment);
  value$1 = parseNumber(value$1);
  type = parseNumber(type);

  if (anyIsError(rate, periods, payment, value$1, type)) {
    return value
  }

  // Return future value
  let result;

  if (rate === 0) {
    result = value$1 + payment * periods;
  } else {
    const term = Math.pow(1 + rate, periods);

    if (type === 1) {
      result = value$1 * term + (payment * (1 + rate) * (term - 1)) / rate;
    } else {
      result = value$1 * term + (payment * (term - 1)) / rate;
    }
  }

  return -result
}

function FVSCHEDULE(principal, schedule) {
  principal = parseNumber(principal);
  schedule = parseNumberArray(flatten(schedule));

  if (anyIsError(principal, schedule)) {
    return value
  }

  const n = schedule.length;
  let future = principal;

  // Apply all interests in schedule

  for (let i = 0; i < n; i++) {
    // Apply scheduled interest
    future *= 1 + schedule[i];
  }

  // Return future value
  return future
}

// TODO
function INTRATE() {
  throw new Error('INTRATE is not implemented')
}

function IPMT(rate, period, periods, present, future, type) {
  // Credits: algorithm inspired by Apache OpenOffice
  future = future || 0;
  type = type || 0;

  rate = parseNumber(rate);
  period = parseNumber(period);
  periods = parseNumber(periods);
  present = parseNumber(present);
  future = parseNumber(future);
  type = parseNumber(type);

  if (anyIsError(rate, period, periods, present, future, type)) {
    return value
  }

  // Compute payment
  const payment = PMT(rate, periods, present, future, type);

  // Compute interest
  let interest;

  if (period === 1) {
    if (type === 1) {
      interest = 0;
    } else {
      interest = -present;
    }
  } else {
    if (type === 1) {
      interest = FV(rate, period - 2, payment, present, 1) - payment;
    } else {
      interest = FV(rate, period - 1, payment, present, 0);
    }
  }

  // Return interest
  return interest * rate
}

function IRR(values, guess) {
  // Credits: algorithm inspired by Apache OpenOffice
  guess = guess || 0;

  values = parseNumberArray(flatten(values));
  guess = parseNumber(guess);

  if (anyIsError(values, guess)) {
    return value
  }

  // Calculates the resulting amount
  const irrResult = (values, dates, rate) => {
    const r = rate + 1;
    let result = values[0];

    for (let i = 1; i < values.length; i++) {
      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
    }

    return result
  };

  // Calculates the first derivation
  const irrResultDeriv = (values, dates, rate) => {
    const r = rate + 1;
    let result = 0;

    for (let i = 1; i < values.length; i++) {
      const frac = (dates[i] - dates[0]) / 365;
      result -= (frac * values[i]) / Math.pow(r, frac + 1);
    }

    return result
  };

  // Initialize dates and check that values contains at least one positive value and one negative value
  const dates = [];
  let positive = false;
  let negative = false;

  for (let i = 0; i < values.length; i++) {
    dates[i] = i === 0 ? 0 : dates[i - 1] + 365;

    if (values[i] > 0) {
      positive = true;
    }

    if (values[i] < 0) {
      negative = true;
    }
  }

  // Return error if values does not contain at least one positive value and one negative value
  if (!positive || !negative) {
    return num
  }

  // Initialize guess and resultRate
  guess = guess === undefined ? 0.1 : guess;
  let resultRate = guess;

  // Set maximum epsilon for end of iteration
  const epsMax = 1e-10;

  // Implement Newton's method
  let newRate, epsRate, resultValue;
  let contLoop = true;
  do {
    resultValue = irrResult(values, dates, resultRate);
    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
    epsRate = Math.abs(newRate - resultRate);
    resultRate = newRate;
    contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
  } while (contLoop)

  // Return internal rate of return
  return resultRate
}

function ISPMT(rate, period, periods, value$1) {
  rate = parseNumber(rate);
  period = parseNumber(period);
  periods = parseNumber(periods);
  value$1 = parseNumber(value$1);

  if (anyIsError(rate, period, periods, value$1)) {
    return value
  }

  // Return interest
  return value$1 * rate * (period / periods - 1)
}

// TODO
function MDURATION() {
  throw new Error('MDURATION is not implemented')
}

function MIRR(values, finance_rate, reinvest_rate) {
  values = parseNumberArray(flatten(values));
  finance_rate = parseNumber(finance_rate);
  reinvest_rate = parseNumber(reinvest_rate);

  if (anyIsError(values, finance_rate, reinvest_rate)) {
    return value
  }

  // Initialize number of values
  const n = values.length;

  // Lookup payments (negative values) and incomes (positive values)
  const payments = [];
  const incomes = [];

  for (let i = 0; i < n; i++) {
    if (values[i] < 0) {
      payments.push(values[i]);
    } else {
      incomes.push(values[i]);
    }
  }

  // Return modified internal rate of return
  const num = -NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
  const den = NPV(finance_rate, payments) * (1 + finance_rate);

  return Math.pow(num / den, 1 / (n - 1)) - 1
}

function NOMINAL(rate, periods) {
  rate = parseNumber(rate);
  periods = parseNumber(periods);

  if (anyIsError(rate, periods)) {
    return value
  }

  // Return error if rate <=0 or periods < 1
  if (rate <= 0 || periods < 1) {
    return num
  }

  // Truncate periods if it is not an integer
  periods = parseInt(periods, 10);

  // Return nominal annual interest rate
  return (Math.pow(rate + 1, 1 / periods) - 1) * periods
}

function NPER(rate, payment, present, future, type) {
  type = type === undefined ? 0 : type;
  future = future === undefined ? 0 : future;

  rate = parseNumber(rate);
  payment = parseNumber(payment);
  present = parseNumber(present);
  future = parseNumber(future);
  type = parseNumber(type);

  if (anyIsError(rate, payment, present, future, type)) {
    return value
  }

  if (rate === 0) {
    return -(present + future) / payment
  } else {
    const num = payment * (1 + rate * type) - future * rate;
    const den = present * rate + payment * (1 + rate * type);

    return Math.log(num / den) / Math.log(1 + rate)
  }
}

function NPV() {
  const args = parseNumberArray(flatten(arguments));

  if (args instanceof Error) {
    return args
  }

  // Lookup rate
  const rate = args[0];

  // Initialize net present value
  let value = 0;

  // Loop on all values

  for (let j = 1; j < args.length; j++) {
    value += args[j] / Math.pow(1 + rate, j);
  }

  // Return net present value
  return value
}

// TODO
function ODDFPRICE() {
  throw new Error('ODDFPRICE is not implemented')
}

// TODO
function ODDFYIELD() {
  throw new Error('ODDFYIELD is not implemented')
}

// TODO
function ODDLPRICE() {
  throw new Error('ODDLPRICE is not implemented')
}

// TODO
function ODDLYIELD() {
  throw new Error('ODDLYIELD is not implemented')
}

function PDURATION(rate, present, future) {
  rate = parseNumber(rate);
  present = parseNumber(present);
  future = parseNumber(future);

  if (anyIsError(rate, present, future)) {
    return value
  }

  // Return error if rate <=0
  if (rate <= 0) {
    return num
  }

  // Return number of periods
  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate)
}

function PMT(rate, periods, present, future, type) {
  // Credits: algorithm inspired by Apache OpenOffice
  future = future || 0;
  type = type || 0;

  rate = parseNumber(rate);
  periods = parseNumber(periods);
  present = parseNumber(present);
  future = parseNumber(future);
  type = parseNumber(type);

  if (anyIsError(rate, periods, present, future, type)) {
    return value
  }

  // Return payment
  let result;

  if (rate === 0) {
    result = (present + future) / periods;
  } else {
    const term = Math.pow(1 + rate, periods);

    if (type === 1) {
      result = ((future * rate) / (term - 1) + (present * rate) / (1 - 1 / term)) / (1 + rate);
    } else {
      result = (future * rate) / (term - 1) + (present * rate) / (1 - 1 / term);
    }
  }

  return -result
}

function PPMT(rate, period, periods, present, future, type) {
  future = future || 0;
  type = type || 0;

  rate = parseNumber(rate);
  periods = parseNumber(periods);
  present = parseNumber(present);
  future = parseNumber(future);
  type = parseNumber(type);

  if (anyIsError(rate, periods, present, future, type)) {
    return value
  }

  return PMT(rate, periods, present, future, type) - IPMT(rate, period, periods, present, future, type)
}

// TODO
function PRICE() {
  throw new Error('PRICE is not implemented')
}

// TODO
function PRICEDISC() {
  throw new Error('PRICEDISC is not implemented')
}

// TODO
function PRICEMAT() {
  throw new Error('PRICEMAT is not implemented')
}

function PV(rate, periods, payment, future, type) {
  future = future || 0;
  type = type || 0;

  rate = parseNumber(rate);
  periods = parseNumber(periods);
  payment = parseNumber(payment);
  future = parseNumber(future);
  type = parseNumber(type);

  if (anyIsError(rate, periods, payment, future, type)) {
    return value
  }

  // Return present value
  if (rate === 0) {
    return -payment * periods - future
  } else {
    return (
      (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods)
    )
  }
}

function RATE(periods, payment, present, future, type, guess) {
  guess = guess === undefined ? 0.01 : guess;
  future = future === undefined ? 0 : future;
  type = type === undefined ? 0 : type;

  periods = parseNumber(periods);
  payment = parseNumber(payment);
  present = parseNumber(present);
  future = parseNumber(future);
  type = parseNumber(type);
  guess = parseNumber(guess);

  if (anyIsError(periods, payment, present, future, type, guess)) {
    return value
  }

  const epsMax = 1e-10;
  const iterMax = 20;
  let rate = guess;

  type = type ? 1 : 0;

  for (let i = 0; i < iterMax; i++) {
    if (rate <= -1) {
      return num
    }

    let y, f;

    if (Math.abs(rate) < epsMax) {
      y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;
    } else {
      f = Math.pow(1 + rate, periods);
      y = present * f + payment * (1 / rate + type) * (f - 1) + future;
    }

    if (Math.abs(y) < epsMax) {
      return rate
    }

    let dy;

    if (Math.abs(rate) < epsMax) {
      dy = present * periods + payment * type * periods;
    } else {
      f = Math.pow(1 + rate, periods);
      const df = periods * Math.pow(1 + rate, periods - 1);
      dy = present * df + payment * (1 / rate + type) * df + payment * (-1 / (rate * rate)) * (f - 1);
    }

    rate -= y / dy;
  }

  return rate
}

// TODO
function RECEIVED() {
  throw new Error('RECEIVED is not implemented')
}

function RRI(periods, present, future) {
  periods = parseNumber(periods);
  present = parseNumber(present);
  future = parseNumber(future);

  if (anyIsError(periods, present, future)) {
    return value
  }

  // Return error if periods or present is equal to 0 (zero)
  if (periods === 0 || present === 0) {
    return num
  }

  // Return equivalent interest rate
  return Math.pow(future / present, 1 / periods) - 1
}

function SLN(cost, salvage, life) {
  cost = parseNumber(cost);
  salvage = parseNumber(salvage);
  life = parseNumber(life);

  if (anyIsError(cost, salvage, life)) {
    return value
  }

  // Return error if life equal to 0 (zero)
  if (life === 0) {
    return num
  }

  // Return straight-line depreciation
  return (cost - salvage) / life
}

function SYD(cost, salvage, life, period) {
  // Return error if any of the parameters is not a number
  cost = parseNumber(cost);
  salvage = parseNumber(salvage);
  life = parseNumber(life);
  period = parseNumber(period);

  if (anyIsError(cost, salvage, life, period)) {
    return value
  }

  // Return error if life equal to 0 (zero)
  if (life === 0) {
    return num
  }

  // Return error if period is lower than 1 or greater than life
  if (period < 1 || period > life) {
    return num
  }

  // Truncate period if it is not an integer
  period = parseInt(period, 10);

  // Return straight-line depreciation
  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1))
}

function TBILLEQ(settlement, maturity, discount) {
  settlement = parseDate(settlement);
  maturity = parseDate(maturity);
  discount = parseNumber(discount);

  if (anyIsError(settlement, maturity, discount)) {
    return value
  }

  // Return error if discount is lower than or equal to zero
  if (discount <= 0) {
    return num
  }

  // Return error if settlement is greater than maturity
  if (settlement > maturity) {
    return num
  }

  // Return error if maturity is more than one year after settlement
  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
    return num
  }

  // Return bond-equivalent yield
  return (365 * discount) / (360 - discount * DAYS360(settlement, maturity, false))
}

function TBILLPRICE(settlement, maturity, discount) {
  settlement = parseDate(settlement);
  maturity = parseDate(maturity);
  discount = parseNumber(discount);

  if (anyIsError(settlement, maturity, discount)) {
    return value
  }

  // Return error if discount is lower than or equal to zero
  if (discount <= 0) {
    return num
  }

  // Return error if settlement is greater than maturity
  if (settlement > maturity) {
    return num
  }

  // Return error if maturity is more than one year after settlement
  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
    return num
  }

  // Return bond-equivalent yield
  return 100 * (1 - (discount * DAYS360(settlement, maturity, false)) / 360)
}

function TBILLYIELD(settlement, maturity, price) {
  settlement = parseDate(settlement);
  maturity = parseDate(maturity);
  price = parseNumber(price);

  if (anyIsError(settlement, maturity, price)) {
    return value
  }

  // Return error if price is lower than or equal to zero
  if (price <= 0) {
    return num
  }

  // Return error if settlement is greater than maturity
  if (settlement > maturity) {
    return num
  }

  // Return error if maturity is more than one year after settlement
  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
    return num
  }

  // Return bond-equivalent yield
  return ((100 - price) * 360) / (price * DAYS360(settlement, maturity, false))
}

// TODO
function VDB() {
  throw new Error('VDB is not implemented')
}

function XIRR(values, dates, guess) {
  // Credits: algorithm inspired by Apache OpenOffice
  values = parseNumberArray(flatten(values));
  dates = parseDateArray(flatten(dates));
  guess = parseNumber(guess);

  if (anyIsError(values, dates, guess)) {
    return value
  }

  // Calculates the resulting amount
  const irrResult = (values, dates, rate) => {
    const r = rate + 1;
    let result = values[0];

    for (let i = 1; i < values.length; i++) {
      result += values[i] / Math.pow(r, DAYS(dates[i], dates[0]) / 365);
    }

    return result
  };

  // Calculates the first derivation
  const irrResultDeriv = (values, dates, rate) => {
    const r = rate + 1;
    let result = 0;

    for (let i = 1; i < values.length; i++) {
      const frac = DAYS(dates[i], dates[0]) / 365;
      result -= (frac * values[i]) / Math.pow(r, frac + 1);
    }

    return result
  };

  // Check that values contains at least one positive value and one negative value
  let positive = false;
  let negative = false;

  for (let i = 0; i < values.length; i++) {
    if (values[i] > 0) {
      positive = true;
    }

    if (values[i] < 0) {
      negative = true;
    }
  }

  // Return error if values does not contain at least one positive value and one negative value
  if (!positive || !negative) {
    return num
  }

  // Initialize guess and resultRate
  guess = guess || 0.1;
  let resultRate = guess;

  // Set maximum epsilon for end of iteration
  const epsMax = 1e-10;

  // Implement Newton's method
  let newRate, epsRate, resultValue;
  let contLoop = true;

  do {
    resultValue = irrResult(values, dates, resultRate);
    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
    epsRate = Math.abs(newRate - resultRate);
    resultRate = newRate;
    contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
  } while (contLoop)

  // Return internal rate of return
  return resultRate
}

function XNPV(rate, values, dates) {
  rate = parseNumber(rate);
  values = parseNumberArray(flatten(values));
  dates = parseDateArray(flatten(dates));

  if (anyIsError(rate, values, dates)) {
    return value
  }

  let result = 0;

  for (let i = 0; i < values.length; i++) {
    result += values[i] / Math.pow(1 + rate, DAYS(dates[i], dates[0]) / 365);
  }

  return result
}

// TODO
function YIELD() {
  throw new Error('YIELD is not implemented')
}

// TODO
function YIELDDISC() {
  throw new Error('YIELDDISC is not implemented')
}

// TODO
function YIELDMAT() {
  throw new Error('YIELDMAT is not implemented')
}

function AND() {
  const args = flatten(arguments);
  let result = value;

  for (let i = 0; i < args.length; i++) {
    if (args[i] instanceof Error) {
      return args[i]
    }

    if (args[i] === undefined || args[i] === null || typeof args[i] === 'string') {
      continue
    }

    if (result === value) {
      result = true;
    }

    if (!args[i]) {
      result = false;
    }
  }

  return result
}

function CHOOSE() {
  if (arguments.length < 2) {
    return na
  }

  const index = arguments[0];

  if (index < 1 || index > 254) {
    return value
  }

  if (arguments.length < index + 1) {
    return value
  }

  return arguments[index]
}

function FALSE() {
  return false
}

function IF(test, then_value, otherwise_value) {
  if (test instanceof Error) {
    return test
  }

  then_value = arguments.length >= 2 ? then_value : true;

  if (then_value === undefined || then_value === null) {
    then_value = 0;
  }

  otherwise_value = arguments.length === 3 ? otherwise_value : false;

  if (otherwise_value === undefined || otherwise_value === null) {
    otherwise_value = 0;
  }

  return test ? then_value : otherwise_value
}

function IFS() {
  for (let i = 0; i < arguments.length / 2; i++) {
    if (arguments[i * 2]) {
      return arguments[i * 2 + 1]
    }
  }

  return na
}

function IFERROR(value, valueIfError) {
  if (ISERROR(value)) {
    return valueIfError
  }

  return value
}

function IFNA(value, value_if_na) {
  return value === na ? value_if_na : value
}

function NOT(logical) {
  if (typeof logical === 'string') {
    return value
  }

  if (logical instanceof Error) {
    return logical
  }

  return !logical
}

function OR() {
  const args = flatten(arguments);
  let result = value;

  for (let i = 0; i < args.length; i++) {
    if (args[i] instanceof Error) {
      return args[i]
    }

    if (args[i] === undefined || args[i] === null || typeof args[i] === 'string') {
      continue
    }

    if (result === value) {
      result = false;
    }

    if (args[i]) {
      result = true;
    }
  }

  return result
}

function TRUE() {
  return true
}

function XOR() {
  const args = flatten(arguments);
  let result = value;

  for (let i = 0; i < args.length; i++) {
    if (args[i] instanceof Error) {
      return args[i]
    }

    if (args[i] === undefined || args[i] === null || typeof args[i] === 'string') {
      continue
    }

    if (result === value) {
      result = 0;
    }

    if (args[i]) {
      result++;
    }
  }

  if (result === value) {
    return result
  }

  return !!(Math.floor(Math.abs(result)) & 1)
}

function SWITCH() {
  let result;

  if (arguments.length > 0) {
    const targetValue = arguments[0];
    const argc = arguments.length - 1;
    const switchCount = Math.floor(argc / 2);
    let switchSatisfied = false;
    const hasDefaultClause = argc % 2 !== 0;
    const defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

    if (switchCount) {
      for (let index = 0; index < switchCount; index++) {
        if (targetValue === arguments[index * 2 + 1]) {
          result = arguments[index * 2 + 2];
          switchSatisfied = true;
          break
        }
      }
    }

    if (!switchSatisfied) {
      result = hasDefaultClause ? defaultClause : na;
    }
  } else {
    result = value;
  }

  return result
}

function MATCH(lookupValue, lookupArray, matchType) {
  if (!lookupValue && !lookupArray) {
    return na
  }

  if (arguments.length === 2) {
    matchType = 1;
  }

  if (!(lookupArray instanceof Array)) {
    return na
  }

  lookupArray = flatten(lookupArray);

  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
    return na
  }

  let index;
  let indexValue;

  for (let idx = 0; idx < lookupArray.length; idx++) {
    if (matchType === 1) {
      if (lookupArray[idx] === lookupValue) {
        return idx + 1
      } else if (lookupArray[idx] < lookupValue) {
        if (!indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        } else if (lookupArray[idx] > indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        }
      }
    } else if (matchType === 0) {
      if (typeof lookupValue === 'string') {
        lookupValue = lookupValue.replace(/\?/g, '.');

        if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
          return idx + 1
        }
      } else {
        if (lookupArray[idx] === lookupValue) {
          return idx + 1
        }
      }
    } else if (matchType === -1) {
      if (lookupArray[idx] === lookupValue) {
        return idx + 1
      } else if (lookupArray[idx] > lookupValue) {
        if (!indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        } else if (lookupArray[idx] < indexValue) {
          index = idx + 1;
          indexValue = lookupArray[idx];
        }
      }
    }
  }

  return index || na
}

function VLOOKUP(needle, table, index, rangeLookup) {
  if (!table || !index) {
    return na
  }

  rangeLookup = !(rangeLookup === 0 || rangeLookup === false);
  let result = na;
  const isNumberLookup = typeof needle === 'number';
  let exactMatchOnly = false;

  for (let i = 0; i < table.length; i++) {
    const row = table[i];

    if (row[0] === needle) {
      result = index < row.length + 1 ? row[index - 1] : ref;
      break
    } else if (
      !exactMatchOnly &&
      ((isNumberLookup && rangeLookup && row[0] <= needle) ||
        (rangeLookup && typeof row[0] === 'string' && row[0].localeCompare(needle) < 0))
    ) {
      result = index < row.length + 1 ? row[index - 1] : ref;
    }

    if (isNumberLookup && row[0] > needle) {
      exactMatchOnly = true;
    }
  }

  return result
}

function HLOOKUP(needle, table, index, rangeLookup) {
  return VLOOKUP(needle, transpose(table), index, rangeLookup)
}

function LOOKUP(searchCriterion, array, resultArray) {
  array = flatten(array);
  resultArray = resultArray ? flatten(resultArray) : array;

  const isNumberLookup = typeof searchCriterion === 'number';
  let result = na;

  for (let i = 0; i < array.length; i++) {
    if (array[i] === searchCriterion) {
      return resultArray[i]
    } else if (
      (isNumberLookup && array[i] <= searchCriterion) ||
      (typeof array[i] === 'string' && array[i].localeCompare(searchCriterion) < 0)
    ) {
      result = resultArray[i];
    } else if (isNumberLookup && array[i] > searchCriterion) {
      return result
    }
  }

  return result
}

function INDEX(cellRange, rowNumber, columnNumber) {
  const someError = anyError(cellRange, rowNumber, columnNumber);

  if (someError) {
    return someError
  }

  if (!Array.isArray(cellRange)) {
    return value
  }

  const isOneDimensionRange = cellRange.length > 0 && !Array.isArray(cellRange[0]);

  if (isOneDimensionRange && !columnNumber) {
    columnNumber = rowNumber;
    rowNumber = 1;
  } else {
    columnNumber = columnNumber || 1;
    rowNumber = rowNumber || 1;
  }

  if (columnNumber < 0 || rowNumber < 0) {
    return value
  }

  if (isOneDimensionRange && rowNumber === 1 && columnNumber <= cellRange.length) {
    return cellRange[columnNumber - 1]
  } else if (rowNumber <= cellRange.length && columnNumber <= cellRange[rowNumber - 1].length) {
    return cellRange[rowNumber - 1][columnNumber - 1]
  }

  return ref
}

exports.ABS = ABS;
exports.ACCRINT = ACCRINT;
exports.ACCRINTM = ACCRINTM;
exports.ACOS = ACOS;
exports.ACOSH = ACOSH;
exports.ACOT = ACOT;
exports.ACOTH = ACOTH;
exports.ADD = ADD;
exports.AGGREGATE = AGGREGATE;
exports.AMORDEGRC = AMORDEGRC;
exports.AMORLINC = AMORLINC;
exports.AND = AND;
exports.ARABIC = ARABIC;
exports.ARGS2ARRAY = ARGS2ARRAY;
exports.ASC = ASC;
exports.ASIN = ASIN;
exports.ASINH = ASINH;
exports.ATAN = ATAN;
exports.ATAN2 = ATAN2;
exports.ATANH = ATANH;
exports.AVEDEV = AVEDEV;
exports.AVERAGE = AVERAGE;
exports.AVERAGEA = AVERAGEA;
exports.AVERAGEIF = AVERAGEIF;
exports.AVERAGEIFS = AVERAGEIFS;
exports.BAHTTEXT = BAHTTEXT;
exports.BASE = BASE;
exports.BESSELI = BESSELI;
exports.BESSELJ = BESSELJ;
exports.BESSELK = BESSELK;
exports.BESSELY = BESSELY;
exports.BETA = BETA;
exports.BETADIST = BETADIST;
exports.BETAINV = BETAINV;
exports.BIN2DEC = BIN2DEC;
exports.BIN2HEX = BIN2HEX;
exports.BIN2OCT = BIN2OCT;
exports.BINOM = BINOM;
exports.BINOMDIST = BINOMDIST;
exports.BITAND = BITAND;
exports.BITLSHIFT = BITLSHIFT;
exports.BITOR = BITOR;
exports.BITRSHIFT = BITRSHIFT;
exports.BITXOR = BITXOR;
exports.CEILING = CEILING;
exports.CEILINGMATH = CEILINGMATH;
exports.CEILINGPRECISE = CEILINGPRECISE;
exports.CELL = CELL;
exports.CHAR = CHAR;
exports.CHIDIST = CHIDIST;
exports.CHIDISTRT = CHIDISTRT;
exports.CHIINV = CHIINV;
exports.CHIINVRT = CHIINVRT;
exports.CHISQ = CHISQ;
exports.CHITEST = CHITEST;
exports.CHOOSE = CHOOSE;
exports.CLEAN = CLEAN;
exports.CODE = CODE;
exports.COLUMN = COLUMN;
exports.COLUMNS = COLUMNS;
exports.COMBIN = COMBIN;
exports.COMBINA = COMBINA;
exports.COMPLEX = COMPLEX;
exports.CONCAT = CONCAT;
exports.CONCATENATE = CONCATENATE;
exports.CONFIDENCE = CONFIDENCE;
exports.CONVERT = CONVERT;
exports.CORREL = CORREL;
exports.COS = COS;
exports.COSH = COSH;
exports.COT = COT;
exports.COTH = COTH;
exports.COUNT = COUNT;
exports.COUNTA = COUNTA;
exports.COUNTBLANK = COUNTBLANK;
exports.COUNTIF = COUNTIF;
exports.COUNTIFS = COUNTIFS;
exports.COUNTIN = COUNTIN;
exports.COUNTUNIQUE = COUNTUNIQUE;
exports.COUPDAYBS = COUPDAYBS;
exports.COUPDAYS = COUPDAYS;
exports.COUPDAYSNC = COUPDAYSNC;
exports.COUPNCD = COUPNCD;
exports.COUPNUM = COUPNUM;
exports.COUPPCD = COUPPCD;
exports.COVAR = COVAR;
exports.COVARIANCE = COVARIANCE;
exports.COVARIANCEP = COVARIANCEP;
exports.COVARIANCES = COVARIANCES;
exports.CRITBINOM = CRITBINOM;
exports.CSC = CSC;
exports.CSCH = CSCH;
exports.CUMIPMT = CUMIPMT;
exports.CUMPRINC = CUMPRINC;
exports.DATE = DATE;
exports.DATEDIF = DATEDIF;
exports.DATEVALUE = DATEVALUE;
exports.DAVERAGE = DAVERAGE;
exports.DAY = DAY;
exports.DAYS = DAYS;
exports.DAYS360 = DAYS360;
exports.DB = DB;
exports.DBCS = DBCS;
exports.DCOUNT = DCOUNT;
exports.DCOUNTA = DCOUNTA;
exports.DDB = DDB;
exports.DEC2BIN = DEC2BIN;
exports.DEC2HEX = DEC2HEX;
exports.DEC2OCT = DEC2OCT;
exports.DECIMAL = DECIMAL;
exports.DEGREES = DEGREES;
exports.DELTA = DELTA;
exports.DEVSQ = DEVSQ;
exports.DGET = DGET;
exports.DISC = DISC;
exports.DIVIDE = DIVIDE;
exports.DMAX = DMAX;
exports.DMIN = DMIN;
exports.DOLLAR = DOLLAR;
exports.DOLLARDE = DOLLARDE;
exports.DOLLARFR = DOLLARFR;
exports.DPRODUCT = DPRODUCT;
exports.DSTDEV = DSTDEV;
exports.DSTDEVP = DSTDEVP;
exports.DSUM = DSUM;
exports.DURATION = DURATION;
exports.DVAR = DVAR;
exports.DVARP = DVARP;
exports.E = E;
exports.EDATE = EDATE;
exports.EFFECT = EFFECT;
exports.EOMONTH = EOMONTH;
exports.EQ = EQ;
exports.ERF = ERF;
exports.ERFC = ERFC;
exports.ERFCPRECISE = ERFCPRECISE;
exports.ERFPRECISE = ERFPRECISE;
exports.ERROR = ERROR;
exports.EVEN = EVEN;
exports.EXACT = EXACT;
exports.EXP = EXP;
exports.EXPON = EXPON;
exports.EXPONDIST = EXPONDIST;
exports.F = F;
exports.FACT = FACT;
exports.FACTDOUBLE = FACTDOUBLE;
exports.FALSE = FALSE;
exports.FDIST = FDIST;
exports.FDISTRT = FDISTRT;
exports.FIND = FIND;
exports.FINDFIELD = FINDFIELD;
exports.FINV = FINV;
exports.FINVRT = FINVRT;
exports.FISHER = FISHER;
exports.FISHERINV = FISHERINV;
exports.FIXED = FIXED;
exports.FLATTEN = FLATTEN;
exports.FLOOR = FLOOR;
exports.FLOORMATH = FLOORMATH;
exports.FLOORPRECISE = FLOORPRECISE;
exports.FORECAST = FORECAST;
exports.FREQUENCY = FREQUENCY;
exports.FTEST = FTEST;
exports.FV = FV;
exports.FVSCHEDULE = FVSCHEDULE;
exports.GAMMA = GAMMA;
exports.GAMMADIST = GAMMADIST;
exports.GAMMAINV = GAMMAINV;
exports.GAMMALN = GAMMALN;
exports.GAMMALNPRECISE = GAMMALNPRECISE;
exports.GAUSS = GAUSS;
exports.GCD = GCD;
exports.GEOMEAN = GEOMEAN;
exports.GESTEP = GESTEP;
exports.GROWTH = GROWTH;
exports.GT = GT;
exports.GTE = GTE;
exports.HARMEAN = HARMEAN;
exports.HEX2BIN = HEX2BIN;
exports.HEX2DEC = HEX2DEC;
exports.HEX2OCT = HEX2OCT;
exports.HLOOKUP = HLOOKUP;
exports.HOUR = HOUR;
exports.HTML2TEXT = HTML2TEXT;
exports.HYPGEOM = HYPGEOM;
exports.HYPGEOMDIST = HYPGEOMDIST;
exports.IF = IF;
exports.IFERROR = IFERROR;
exports.IFNA = IFNA;
exports.IFS = IFS;
exports.IMABS = IMABS;
exports.IMAGINARY = IMAGINARY;
exports.IMARGUMENT = IMARGUMENT;
exports.IMCONJUGATE = IMCONJUGATE;
exports.IMCOS = IMCOS;
exports.IMCOSH = IMCOSH;
exports.IMCOT = IMCOT;
exports.IMCSC = IMCSC;
exports.IMCSCH = IMCSCH;
exports.IMDIV = IMDIV;
exports.IMEXP = IMEXP;
exports.IMLN = IMLN;
exports.IMLOG10 = IMLOG10;
exports.IMLOG2 = IMLOG2;
exports.IMPOWER = IMPOWER;
exports.IMPRODUCT = IMPRODUCT;
exports.IMREAL = IMREAL;
exports.IMSEC = IMSEC;
exports.IMSECH = IMSECH;
exports.IMSIN = IMSIN;
exports.IMSINH = IMSINH;
exports.IMSQRT = IMSQRT;
exports.IMSUB = IMSUB;
exports.IMSUM = IMSUM;
exports.IMTAN = IMTAN;
exports.INDEX = INDEX;
exports.INFO = INFO;
exports.INT = INT;
exports.INTERCEPT = INTERCEPT;
exports.INTERVAL = INTERVAL;
exports.INTRATE = INTRATE;
exports.IPMT = IPMT;
exports.IRR = IRR;
exports.ISBINARY = ISBINARY;
exports.ISBLANK = ISBLANK;
exports.ISERR = ISERR;
exports.ISERROR = ISERROR;
exports.ISEVEN = ISEVEN;
exports.ISFORMULA = ISFORMULA;
exports.ISLOGICAL = ISLOGICAL;
exports.ISNA = ISNA;
exports.ISNONTEXT = ISNONTEXT;
exports.ISNUMBER = ISNUMBER;
exports.ISO = ISO;
exports.ISODD = ISODD;
exports.ISOWEEKNUM = ISOWEEKNUM;
exports.ISPMT = ISPMT;
exports.ISREF = ISREF;
exports.ISTEXT = ISTEXT;
exports.JOIN = JOIN;
exports.KURT = KURT;
exports.LARGE = LARGE;
exports.LCM = LCM;
exports.LEFT = LEFT;
exports.LEN = LEN;
exports.LINEST = LINEST;
exports.LN = LN;
exports.LN10 = LN10;
exports.LN2 = LN2;
exports.LOG = LOG;
exports.LOG10 = LOG10;
exports.LOG10E = LOG10E;
exports.LOG2E = LOG2E;
exports.LOGEST = LOGEST;
exports.LOGINV = LOGINV;
exports.LOGNORM = LOGNORM;
exports.LOGNORMDIST = LOGNORMDIST;
exports.LOGNORMINV = LOGNORMINV;
exports.LOOKUP = LOOKUP;
exports.LOWER = LOWER;
exports.LT = LT;
exports.LTE = LTE;
exports.MATCH = MATCH;
exports.MAX = MAX;
exports.MAXA = MAXA;
exports.MDURATION = MDURATION;
exports.MEDIAN = MEDIAN;
exports.MID = MID;
exports.MIN = MIN;
exports.MINA = MINA;
exports.MINUS = MINUS;
exports.MINUTE = MINUTE;
exports.MIRR = MIRR;
exports.MOD = MOD;
exports.MODE = MODE;
exports.MODEMULT = MODEMULT;
exports.MODESNGL = MODESNGL;
exports.MONTH = MONTH;
exports.MROUND = MROUND;
exports.MULTINOMIAL = MULTINOMIAL;
exports.MULTIPLY = MULTIPLY;
exports.N = N;
exports.NA = NA;
exports.NE = NE;
exports.NEGBINOM = NEGBINOM;
exports.NEGBINOMDIST = NEGBINOMDIST;
exports.NETWORKDAYS = NETWORKDAYS;
exports.NETWORKDAYSINTL = NETWORKDAYSINTL;
exports.NOMINAL = NOMINAL;
exports.NORM = NORM;
exports.NORMDIST = NORMDIST;
exports.NORMINV = NORMINV;
exports.NORMSDIST = NORMSDIST;
exports.NORMSINV = NORMSINV;
exports.NOT = NOT;
exports.NOW = NOW;
exports.NPER = NPER;
exports.NPV = NPV;
exports.NUMBERS = NUMBERS;
exports.NUMBERVALUE = NUMBERVALUE;
exports.OCT2BIN = OCT2BIN;
exports.OCT2DEC = OCT2DEC;
exports.OCT2HEX = OCT2HEX;
exports.ODD = ODD;
exports.ODDFPRICE = ODDFPRICE;
exports.ODDFYIELD = ODDFYIELD;
exports.ODDLPRICE = ODDLPRICE;
exports.ODDLYIELD = ODDLYIELD;
exports.OR = OR;
exports.PDURATION = PDURATION;
exports.PEARSON = PEARSON;
exports.PERCENTILE = PERCENTILE;
exports.PERCENTILEEXC = PERCENTILEEXC;
exports.PERCENTILEINC = PERCENTILEINC;
exports.PERCENTRANK = PERCENTRANK;
exports.PERCENTRANKEXC = PERCENTRANKEXC;
exports.PERCENTRANKINC = PERCENTRANKINC;
exports.PERMUT = PERMUT;
exports.PERMUTATIONA = PERMUTATIONA;
exports.PHI = PHI;
exports.PI = PI;
exports.PMT = PMT;
exports.POISSON = POISSON;
exports.POISSONDIST = POISSONDIST;
exports.POW = POW;
exports.POWER = POWER;
exports.PPMT = PPMT;
exports.PRICE = PRICE;
exports.PRICEDISC = PRICEDISC;
exports.PRICEMAT = PRICEMAT;
exports.PROB = PROB;
exports.PRODUCT = PRODUCT;
exports.PRONETIC = PRONETIC;
exports.PROPER = PROPER;
exports.PV = PV;
exports.QUARTILE = QUARTILE;
exports.QUARTILEEXC = QUARTILEEXC;
exports.QUARTILEINC = QUARTILEINC;
exports.QUOTIENT = QUOTIENT;
exports.RADIANS = RADIANS;
exports.RAND = RAND;
exports.RANDBETWEEN = RANDBETWEEN;
exports.RANK = RANK;
exports.RANKAVG = RANKAVG;
exports.RANKEQ = RANKEQ;
exports.RATE = RATE;
exports.RECEIVED = RECEIVED;
exports.REFERENCE = REFERENCE;
exports.REGEXEXTRACT = REGEXEXTRACT;
exports.REGEXMATCH = REGEXMATCH;
exports.REGEXREPLACE = REGEXREPLACE;
exports.REPLACE = REPLACE;
exports.REPT = REPT;
exports.RIGHT = RIGHT;
exports.ROMAN = ROMAN;
exports.ROUND = ROUND;
exports.ROUNDDOWN = ROUNDDOWN;
exports.ROUNDUP = ROUNDUP;
exports.ROW = ROW;
exports.ROWS = ROWS;
exports.RRI = RRI;
exports.RSQ = RSQ;
exports.SEARCH = SEARCH;
exports.SEC = SEC;
exports.SECH = SECH;
exports.SECOND = SECOND;
exports.SERIESSUM = SERIESSUM;
exports.SHEET = SHEET;
exports.SHEETS = SHEETS;
exports.SIGN = SIGN;
exports.SIN = SIN;
exports.SINH = SINH;
exports.SKEW = SKEW;
exports.SKEWP = SKEWP;
exports.SLN = SLN;
exports.SLOPE = SLOPE;
exports.SMALL = SMALL;
exports.SPLIT = SPLIT;
exports.SQRT = SQRT;
exports.SQRT1_2 = SQRT1_2;
exports.SQRT2 = SQRT2;
exports.SQRTPI = SQRTPI;
exports.STANDARDIZE = STANDARDIZE;
exports.STDEV = STDEV;
exports.STDEVA = STDEVA;
exports.STDEVP = STDEVP;
exports.STDEVPA = STDEVPA;
exports.STDEVS = STDEVS;
exports.STEYX = STEYX;
exports.SUBSTITUTE = SUBSTITUTE;
exports.SUBTOTAL = SUBTOTAL;
exports.SUM = SUM;
exports.SUMIF = SUMIF;
exports.SUMIFS = SUMIFS;
exports.SUMPRODUCT = SUMPRODUCT;
exports.SUMSQ = SUMSQ;
exports.SUMX2MY2 = SUMX2MY2;
exports.SUMX2PY2 = SUMX2PY2;
exports.SUMXMY2 = SUMXMY2;
exports.SWITCH = SWITCH;
exports.SYD = SYD;
exports.T = T$1;
exports.TAN = TAN;
exports.TANH = TANH;
exports.TBILLEQ = TBILLEQ;
exports.TBILLPRICE = TBILLPRICE;
exports.TBILLYIELD = TBILLYIELD;
exports.TDIST = TDIST;
exports.TDISTRT = TDISTRT;
exports.TEXT = TEXT;
exports.TEXTJOIN = TEXTJOIN;
exports.TIME = TIME;
exports.TIMEVALUE = TIMEVALUE;
exports.TINV = TINV;
exports.TODAY = TODAY;
exports.TRANSPOSE = TRANSPOSE;
exports.TREND = TREND;
exports.TRIM = TRIM;
exports.TRIMMEAN = TRIMMEAN;
exports.TRUE = TRUE;
exports.TRUNC = TRUNC;
exports.TTEST = TTEST;
exports.TYPE = TYPE;
exports.UNICHAR = UNICHAR;
exports.UNICODE = UNICODE;
exports.UNIQUE = UNIQUE;
exports.UPPER = UPPER;
exports.VALUE = VALUE;
exports.VAR = VAR;
exports.VARA = VARA;
exports.VARP = VARP;
exports.VARPA = VARPA;
exports.VARS = VARS;
exports.VDB = VDB;
exports.VLOOKUP = VLOOKUP;
exports.WEEKDAY = WEEKDAY;
exports.WEEKNUM = WEEKNUM;
exports.WEIBULL = WEIBULL;
exports.WEIBULLDIST = WEIBULLDIST;
exports.WORKDAY = WORKDAY;
exports.WORKDAYINTL = WORKDAYINTL;
exports.XIRR = XIRR;
exports.XNPV = XNPV;
exports.XOR = XOR;
exports.YEAR = YEAR;
exports.YEARFRAC = YEARFRAC;
exports.YIELD = YIELD;
exports.YIELDDISC = YIELDDISC;
exports.YIELDMAT = YIELDMAT;
exports.Z = Z;
exports.ZTEST = ZTEST;
